<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Parsec Book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">2.</strong> Overview</a></li><li class="chapter-item expanded "><a href="service_api_coverage.html"><strong aria-hidden="true">3.</strong> Service API coverage</a></li><li class="chapter-item expanded "><a href="clients_api_coverage.html"><strong aria-hidden="true">4.</strong> Clients API coverage</a></li><li class="chapter-item expanded "><a href="threat_model/threat_model.html"><strong aria-hidden="true">5.</strong> Parsec Threat Model</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="threat_model/secure_deployment.html"><strong aria-hidden="true">5.1.</strong> Recommendations for Secure Deployment</a></li></ol></li><li class="chapter-item expanded "><a href="threat_model/rust_client_threat_model.html"><strong aria-hidden="true">6.</strong> Parsec Rust Client Threat Model</a></li><li class="chapter-item expanded "><a href="parsec_users.html"><strong aria-hidden="true">7.</strong> Parsec for users</a></li><li class="chapter-item expanded "><a href="parsec_client/index.html"><strong aria-hidden="true">8.</strong> Parsec for client developers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="parsec_client/operations/index.html"><strong aria-hidden="true">8.1.</strong> Operations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="parsec_client/operations/add_client.html"><strong aria-hidden="true">8.1.1.</strong> AddClient</a></li><li class="chapter-item expanded "><a href="parsec_client/operations/list_opcodes.html"><strong aria-hidden="true">8.1.2.</strong> ListOpcodes</a></li><li class="chapter-item expanded "><a href="parsec_client/operations/list_providers.html"><strong aria-hidden="true">8.1.3.</strong> ListProviders</a></li><li class="chapter-item expanded "><a href="parsec_client/operations/ping.html"><strong aria-hidden="true">8.1.4.</strong> Ping</a></li><li class="chapter-item expanded "><a href="parsec_client/operations/prove_client.html"><strong aria-hidden="true">8.1.5.</strong> ProveClient</a></li><li class="chapter-item expanded "><a href="parsec_client/operations/psa_destroy_key.html"><strong aria-hidden="true">8.1.6.</strong> PsaDestroyKey</a></li><li class="chapter-item expanded "><a href="parsec_client/operations/psa_export_public_key.html"><strong aria-hidden="true">8.1.7.</strong> PsaExportPublicKey</a></li><li class="chapter-item expanded "><a href="parsec_client/operations/psa_export_key.html"><strong aria-hidden="true">8.1.8.</strong> PsaExportKey</a></li><li class="chapter-item expanded "><a href="parsec_client/operations/psa_generate_key.html"><strong aria-hidden="true">8.1.9.</strong> PsaGenerateKey</a></li><li class="chapter-item expanded "><a href="parsec_client/operations/psa_import_key.html"><strong aria-hidden="true">8.1.10.</strong> PsaImportKey</a></li><li class="chapter-item expanded "><a href="parsec_client/operations/psa_sign_hash.html"><strong aria-hidden="true">8.1.11.</strong> PsaSignHash</a></li><li class="chapter-item expanded "><a href="parsec_client/operations/psa_key_attributes.html"><strong aria-hidden="true">8.1.12.</strong> PSA Key Attributes</a></li><li class="chapter-item expanded "><a href="parsec_client/operations/psa_algorithm.html"><strong aria-hidden="true">8.1.13.</strong> PSA Algorithm</a></li><li class="chapter-item expanded "><a href="parsec_client/operations/psa_verify_hash.html"><strong aria-hidden="true">8.1.14.</strong> PsaVerifyHash</a></li><li class="chapter-item expanded "><a href="parsec_client/operations/psa_asymmetric_encrypt.html"><strong aria-hidden="true">8.1.15.</strong> PsaAsymmetricEncrypt</a></li><li class="chapter-item expanded "><a href="parsec_client/operations/psa_asymmetric_decrypt.html"><strong aria-hidden="true">8.1.16.</strong> PsaAsymmetricDecrypt</a></li><li class="chapter-item expanded "><a href="parsec_client/operations/share_trust_bundle.html"><strong aria-hidden="true">8.1.17.</strong> ShareTrustBundle</a></li></ol></li><li class="chapter-item expanded "><a href="parsec_client/api_overview.html"><strong aria-hidden="true">8.2.</strong> API Overview</a></li><li class="chapter-item expanded "><a href="parsec_client/status_codes.html"><strong aria-hidden="true">8.3.</strong> Status Codes</a></li><li class="chapter-item expanded "><a href="parsec_client/wire_protocol.html"><strong aria-hidden="true">8.4.</strong> Wire Protocol</a></li><li class="chapter-item expanded "><a href="parsec_client/writing_library.html"><strong aria-hidden="true">8.5.</strong> Writing a new Parsec Client Library</a></li></ol></li><li class="chapter-item expanded "><a href="parsec_service/index.html"><strong aria-hidden="true">9.</strong> Parsec for service developers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="parsec_service/system_architecture.html"><strong aria-hidden="true">9.1.</strong> System Architecture</a></li><li class="chapter-item expanded "><a href="parsec_service/interfaces_and_dataflow.html"><strong aria-hidden="true">9.2.</strong> Interfaces and Dataflow</a></li><li class="chapter-item expanded "><a href="parsec_service/source_code_structure.html"><strong aria-hidden="true">9.3.</strong> Source Code Structure</a></li><li class="chapter-item expanded "><a href="parsec_service/providers.html"><strong aria-hidden="true">9.4.</strong> Providers</a></li><li class="chapter-item expanded "><a href="parsec_service/converters.html"><strong aria-hidden="true">9.5.</strong> Converters</a></li><li class="chapter-item expanded "><a href="parsec_service/authenticators.html"><strong aria-hidden="true">9.6.</strong> Authenticators</a></li><li class="chapter-item expanded "><a href="parsec_service/listeners.html"><strong aria-hidden="true">9.7.</strong> Listeners</a></li><li class="chapter-item expanded "><a href="parsec_service/key_info_managers.html"><strong aria-hidden="true">9.8.</strong> Key Info Managers</a></li><li class="chapter-item expanded "><a href="parsec_service/adding_provider.html"><strong aria-hidden="true">9.9.</strong> Adding a new Parsec Provider</a></li><li class="chapter-item expanded "><a href="parsec_service/build_run.html"><strong aria-hidden="true">9.10.</strong> How to build and run Parsec</a></li><li class="chapter-item expanded "><a href="parsec_service/install_parsec_linux.html"><strong aria-hidden="true">9.11.</strong> How to securely install Parsec on Linux</a></li><li class="chapter-item expanded "><a href="parsec_service/configuration.html"><strong aria-hidden="true">9.12.</strong> Parsec Configuration</a></li><li class="chapter-item expanded "><a href="parsec_service/test.html"><strong aria-hidden="true">9.13.</strong> How to test Parsec</a></li></ol></li><li class="chapter-item expanded "><a href="contributing/index.html"><strong aria-hidden="true">10.</strong> Contributing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contributing/adding_new_operation_how_to.html"><strong aria-hidden="true">10.1.</strong> How to add operations to Parsec</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Parsec Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#parsec" id="parsec">Parsec</a></h1>
<p><strong>Parsec</strong> is the <strong>P</strong>latform <strong>A</strong>bst<strong>R</strong>action for <strong>SEC</strong>urity, a new open-source initiative to
provide a common API to secure services in a platform-agnostic way.</p>
<p>Find here all the technical documentation of Parsec, alongside user and developer guides.</p>
<h1><a class="header" href="#disclaimer" id="disclaimer">Disclaimer</a></h1>
<p>Parsec is a new open source project and is under development. This code repository is being made
available so that the developer community can learn and give feedback about the new interfaces and
the concepts of platform-agnostic security. The implementation that is provided is suitable for
exploratory testing and experimentation only. This test implementation does not offer any tangible
security benefits and therefore is not suitable for use in production. Documentation pages may be
incomplete and are subject to change without notice. Interfaces may change in such a way as to break
compatibility with client code. Contributions from the developer community are welcome. Please refer
to the contribution guidelines.</p>
<h1><a class="header" href="#license" id="license">License</a></h1>
<p>Parsec and all the repositories under the <code>parallaxsecond</code> organization are provided under
Apache-2.0. Contributions to this project are accepted under the same license.</p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#welcome-to-parsec" id="welcome-to-parsec">Welcome to Parsec</a></h1>
<p><strong>Parsec</strong> is the <strong>P</strong>latform <strong>A</strong>bst<strong>R</strong>action for <strong>SEC</strong>urity, a new open-source initiative to
provide a common <a href="parsec_client/api_overview.html">API</a> to secure services in a platform-agnostic way.</p>
<p>Parsec aims to define a universal software standard for interacting with secure object storage and
cryptography services, creating a common way to interface with functions that would traditionally
have been accessed by more specialised APIs. Parsec establishes an ecosystem of developer-friendly
libraries in a variety of popular programming languages. Each library is designed to be highly
ergonomic and simple to consume. This growing ecosystem will put secure facilities at the fingertips
of developers across a broad range of use cases in infrastructure computing, edge computing and the
secure Internet of Things.</p>
<h1><a class="header" href="#why-platform-agnostic-security" id="why-platform-agnostic-security">Why Platform-Agnostic Security?</a></h1>
<p>Today's computing platforms have evolved to offer a range of facilities for secure storage and
secure operations. There are hardware-backed facilities such as the Hardware Security Module (HSM)
or Trusted Platform Module (TPM). There are firmware services running in Trusted Execution
Environments (TEE). There are also cloud-based security services. At a bare minimum, security
facilities may be provided purely in software, where they are protected by mechanisms provided in
the operating system.</p>
<p>Over the years, software standards have emerged to allow developers to use these facilities from
their applications. But these standards bring with them the following challenges:</p>
<ul>
<li>They are defined with the expectation that the caller is the &quot;owner&quot; of the platform, meaning that
it has sole access to the underlying hardware. In reality, this is often not the case, because
the caller might reside in a container or virtual machine, where it is sharing the host hardware
with other applications. Existing software standards do not cater well for this situation.</li>
<li>They are defined exhaustively, with lengthy specifications detailing all permissible operations
and parameters. They are written from the perspective of the security device and its
capabilities, rather than from the perspective of the application and its use case. This can
offer a daunting and bewildering experience for developers, who spend a lot of time and effort
figuring out how to map their use case onto the API. There is nothing to tailor the API so that
it can be consumed easily for common, simple cases.</li>
<li>They are specific to a programming language such as C. To consume them in other languages, it is
necessary to use interoperability layers such as Foreign Function Interface (FFI), which can make
the developer experience even more cumbersome and unnatural. Interoperability layers can also be
a source of vulnerabilities.</li>
<li>Standards tend to be adopted based on some knowledge of the target platform. So while it might be
possible for code to be portable across multiple HSM vendors, for example, it is much harder to
make code portable between an HSM-based platform and a TPM-based platform.</li>
</ul>
<p>Parsec inverts this traditional approach to standardizing security interfaces, and it does so by
putting applications front and center. It offers an API that is no less comprehensive, but it does
so in a way that puts the needs of applications and their common use cases first.</p>
<p>Applications simply want the best-available security, and they want to be able to consume it in a
way that is simple, natural, and hard to get wrong.</p>
<p>The following observations can be made about such applications:</p>
<ul>
<li>They can be written in a variety of programming languages.</li>
<li>They may be written with no explicit knowledge of the hardware capabilities of the target
platform, such as whether an HSM or TPM is available.</li>
<li>They are often sharing the target platform hardware with other applications due to the use of
virtualization or containerization technology.</li>
<li>The secure assets owned by one application must be isolated from those owned by another. For
example, private keys provisioned on a hardware device must be isolated such that only the
provisioning application would be able to perform subsequent operations with those keys.</li>
<li>They have differing requirements in terms of permissible cryptographic algorithms and key
strengths.</li>
</ul>
<p>These observations motivate the need for a new platform abstraction that offers a common palette of
security primitives via a software interface that is both agnostic with respect to the underlying
hardware capabilities, and also capable of supporting multiple client applications on the same host,
whether those be within containers or within traditional virtual machines.</p>
<p>Parsec is a new software architecture and ecosystem that addresses this need.</p>
<h1><a class="header" href="#basis-in-platform-security-architecture" id="basis-in-platform-security-architecture">Basis in Platform Security Architecture</a></h1>
<p>Parsec is founded on the <a href="https://developer.arm.com/architectures/security-architectures/platform-security-architecture"><strong>Platform Security Architecture
(PSA)</strong></a>.
The PSA is a holistic set of threat models, security analyses, hardware and firmware architecture
specifications, and an open source firmware reference implementation. The PSA provides a recipe,
based on industry best practice, that allows security to be consistently designed in, at both a
hardware and firmware level.</p>
<p>One of the provisions of the PSA is the <a href="https://github.com/ARMmbed/mbed-crypto/blob/psa-crypto-api/docs/PSA_Cryptography_API_Specification.pdf"><strong>PSA Crypto
API</strong></a>.
The PSA Crypto API is a comprehensive library of modern security primitives covering the following
functional areas:</p>
<ul>
<li>Key provisioning and management</li>
<li>Hashing</li>
<li>Signing</li>
<li>Message Authentication Codes (MAC)</li>
<li>Asymmetric encryption</li>
<li>Symmetric encryption</li>
<li>Authenticated Encryption with Associated Data (AEAD)</li>
<li>Key derivation</li>
<li>Entropy (random number generation)</li>
</ul>
<p>A crucial characteristic of the PSA Crypto API is that applications always reference the keys
opaquely, making it ideally suited to implementations where keys are provisioned within hardware and
are never exposed.</p>
<p>The PSA Crypto API is defined in the C language. Parsec adopts the operations and contracts of the C
API, and uses them as the basis for a language-independent <a href="parsec_client/wire_protocol.html"><strong>wire
protocol</strong></a>. Each <a href="parsec_client/operations">operation</a> is defined,
along with all of its inputs and outputs, as a serializable contract, making it suitable to be
invoked over an Inter-Process Communication (IPC) transport. Parsec maintains functional equivalence
with the PSA Crypto API, but allows for out-of-process callers in any programming language.</p>
<h1><a class="header" href="#the-parsec-service" id="the-parsec-service">The Parsec Service</a></h1>
<p>The core component of Parsec is the <strong>security service</strong> (or <strong>security daemon</strong>). This is a
background process that runs on the host platform and provides connectivity with the secure
facilities of that host and surfaces the wire protocol based on PSA Crypto.</p>
<p>The security service listens on a suitable transport medium. The transport technology is one of
Parsec's many pluggable components, and no single transport is mandated. Choice of transport is
dependent on the operating system and the deployment. On Linux-based systems where the client
applications are running in containers (isolation with a shared kernel), the transport can be based
on Unix sockets.</p>
<p>Client applications make connections with the service by posting API requests to the transport
endpoint. This is usually done via a client library that hides the details of both the wire protocol
and the transport. This is one of the ways in which the client library simplifies the experience of
Parsec for application developers.</p>
<p>A single instance of the Parsec service executes on each physical host. In virtualized environments,
the Parsec service may reside on a specially-assigned guest, or potentially within the hypervisor.</p>
<p>The security service does not support remote client applications. Each physical host or node must
have its own instance of the service. However, it is possible for the service to initiate outbound
remote calls of other services, such as cloud-hosted HSM services.</p>
<h1><a class="header" href="#multitenancy-and-access-control" id="multitenancy-and-access-control">Multitenancy and Access Control</a></h1>
<p>In addition to surfacing the common API, the Parsec service is also responsible for brokering access
to the underlying security facilities amongst the multiple client applications. The exact way that
this is done will vary from one deployment to another. (See the section below on pluggable back-end
modules). Some of the brokering functionality may already reside in kernel drivers and other parts
of the software stack. The Parsec service is responsible for creating isolated views of key storage
and cryptographic services for each client application. The secure assets of one client must be kept
protected from those of another.</p>
<p>Central to this multi-tenant operation is the notion of <strong>application identity</strong> and the need for a
separate <strong>identity provider</strong> service. A Parsec-enabled host must contain an identity provider
service in addition to the Parsec service itself.</p>
<p>For more information about application identities and the identity provider, please refer to the
<a href="parsec_service/system_architecture.html"><strong>system architecture</strong></a> document.</p>
<h1><a class="header" href="#pluggable-back-end-modules" id="pluggable-back-end-modules">Pluggable Back-End Modules</a></h1>
<p>The Parsec service employs a layered architecture, structured into a front-end and a back-end.</p>
<p>The front-end module provides the transport endpoint and listens for connections from clients. The
front-end understands the wire protocol and the common API. It is responsible for serialization and
de-serialization of the operation contracts.</p>
<p>The back-end modules are known as <strong>providers</strong>. An instance of the Parsec security service can load
one or more providers. Providers implement the API operations using platform-specific or
vendor-specific code. They provide the &quot;last mile&quot; of connectivity down to the underlying hardware,
software or firmware.</p>
<p>For a deeper dive into the modular structure of the Parsec service, please take a look at the
<a href="parsec_service/interfaces_and_dataflow.html"><strong>interfaces and dataflow</strong></a> design document.</p>
<p>Then delve into the <a href="parsec_service/source_code_structure.html"><strong>source code</strong></a> to discover the
back-end provider modules that exist. If you cannot find one that is compatible with the platform
you intend to use, then please consider contributing a new provider.</p>
<h1><a class="header" href="#beautiful-client-libraries" id="beautiful-client-libraries">Beautiful Client Libraries</a></h1>
<p>A key aim of Parsec is to evolve an ecosystem of developer-friendly client libraries in multiple
programming languages.</p>
<p>Parsec avoids the cumbersome, auto-generated language bindings that are so often a part of
standardized interfaces.</p>
<p>Parsec's client libraries are beautiful.</p>
<p>Each client library is carefully crafted to follow the idioms of the language that it targets.
Consuming a Parsec client library will always feel natural to a developer who works in that
language. Everything from naming conventions to object lifecycle will be blended to create a
highly-idiomatic developer experience.</p>
<p>But Parsec's focus on developer ergonomics goes further than this. Parsec's client interface is
filled with conveniences to eliminate complexity unless complexity is required. The Parsec API is
functionally equivalent with the PSA Crypto API, and none of this functional completeness is lost in
the client layer. All possible variants of key type and algorithm type are exposed in case they are
needed. But the client library offers smart default behaviours so that simple use cases can be
achieved with very little code. Parsec enables client code to be small and elegant. And even if it
needs to be less small, it should still be elegant.</p>
<h1><a class="header" href="#source-code-structure" id="source-code-structure">Source Code Structure</a></h1>
<p>Parsec is composed of multiple code repositories. For more information about how the code in the
repository is organized, please see the <a href="parsec_service/source_code_structure.html"><strong>source code
structure</strong></a> document.</p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#psa-cryptography-api-coverage-within-parsec" id="psa-cryptography-api-coverage-within-parsec">PSA Cryptography API coverage within Parsec</a></h1>
<p>The current interface contracts defined for communication between Parsec and its clients is tracking
the <a href="https://developer.arm.com/architectures/security-architectures/platform-security-architecture/documentation">PSA Cryptography API version
1.0</a>.
This page describes the current state of Parsec support for the operations, attributes and options
that are defined in that specification. It covers two different sides of the issue:</p>
<ul>
<li>Coverage of the suite of operations that have been <a href="https://github.com/parallaxsecond/parsec-operations">defined for
IPC</a> and which can be requested from the
service.</li>
<li>Coverage of the operations and key attributes implemented for each provider (that is offered as
part of the Parsec service).</li>
</ul>
<p><strong>NOTE:</strong> This is not a representation of the coverage available to clients using any particular
programming language. In that regard see the <a href="clients_api_coverage.html">clients API coverage page</a>.</p>
<h2><a class="header" href="#ipc-operations-coverage" id="ipc-operations-coverage">IPC operations coverage</a></h2>
<p>The table below shows coverage only for single part operations. Multi-part operations will be added
in the future and will be organized by operation type.</p>
<h3><a class="header" href="#single-part-operations" id="single-part-operations">Single part operations</a></h3>
<table><thead><tr><th>Operation name</th><th>Protobuf contract exists</th></tr></thead><tbody>
<tr><td><code>psa_import_key</code></td><td><a href="https://github.com/parallaxsecond/parsec-operations/blob/master/protobuf/psa_import_key.proto">✅</a></td></tr>
<tr><td><code>psa_generate_key</code></td><td><a href="https://github.com/parallaxsecond/parsec-operations/blob/master/protobuf/psa_generate_key.proto">✅</a></td></tr>
<tr><td><code>psa_key_derivation_output_key</code></td><td>❌</td></tr>
<tr><td><code>psa_copy_key</code></td><td>❌</td></tr>
<tr><td><code>psa_export_public_key</code></td><td><a href="https://github.com/parallaxsecond/parsec-operations/blob/master/protobuf/psa_export_public_key.proto">✅</a></td></tr>
<tr><td><code>psa_export_key</code></td><td><a href="https://github.com/parallaxsecond/parsec-operations/blob/master/protobuf/psa_export_key.proto">✅</a></td></tr>
<tr><td><code>psa_purge_key</code></td><td>❌</td></tr>
<tr><td><code>psa_destroy_key</code></td><td><a href="https://github.com/parallaxsecond/parsec-operations/blob/master/protobuf/psa_destroy_key.proto">✅</a></td></tr>
<tr><td><code>psa_hash_compute</code></td><td>❌</td></tr>
<tr><td><code>psa_hash_compare</code></td><td>❌</td></tr>
<tr><td><code>psa_mac_compute</code></td><td>❌</td></tr>
<tr><td><code>psa_mac_verify</code></td><td>❌</td></tr>
<tr><td><code>psa_cipher_encrypt</code></td><td>❌</td></tr>
<tr><td><code>psa_cipher_decrypt</code></td><td>❌</td></tr>
<tr><td><code>psa_aead_encrypt</code></td><td>❌</td></tr>
<tr><td><code>psa_aead_decrypt</code></td><td>❌</td></tr>
<tr><td><code>psa_asymmetric_encrypt</code></td><td><a href="https://github.com/parallaxsecond/parsec-operations/blob/master/protobuf/psa_asymmetric_encrypt.proto">✅</a></td></tr>
<tr><td><code>psa_asymmetric_decrypt</code></td><td><a href="https://github.com/parallaxsecond/parsec-operations/blob/master/protobuf/psa_asymmetric_decrypt.proto">✅</a></td></tr>
<tr><td><code>psa_sign_message</code></td><td>❌</td></tr>
<tr><td><code>psa_verify_message</code></td><td>❌</td></tr>
<tr><td><code>psa_sign_hash</code></td><td><a href="https://github.com/parallaxsecond/parsec-operations/blob/master/protobuf/psa_sign_hash.proto">✅</a></td></tr>
<tr><td><code>psa_verify_hash</code></td><td><a href="https://github.com/parallaxsecond/parsec-operations/blob/master/protobuf/psa_verify_hash.proto">✅</a></td></tr>
<tr><td><code>psa_key_derivation_key_agreement</code></td><td>❌</td></tr>
<tr><td><code>psa_raw_key_agreement</code></td><td>❌</td></tr>
</tbody></table>
<p>You can help increase Parsec's API coverage! Take a look at our
<a href="contributing/adding_new_operation_how_to.html">how-to</a> to get started.</p>
<h2><a class="header" href="#api-support-per-provider" id="api-support-per-provider">API support per-provider</a></h2>
<p>This section gives information on the operations and attributes currently supported by each
provider. Only support for the operations marked as covered in the table(s) above is considered. Any
option marked as supported is necessarily supported for all operations on which it is usable.</p>
<h3><a class="header" href="#operation-support" id="operation-support">Operation support</a></h3>
<table><thead><tr><th>Operation</th><th>Mbed Crypto provider</th><th>PKCS 11 provider</th><th>TPM 2.0 provider</th></tr></thead><tbody>
<tr><td>Import key</td><td>✅</td><td>✅</td><td>✅</td></tr>
<tr><td>Generate key</td><td>✅</td><td>✅</td><td>✅</td></tr>
<tr><td>Export public key</td><td>✅</td><td>✅</td><td>✅</td></tr>
<tr><td>Export key</td><td>✅</td><td>❌</td><td>❌</td></tr>
<tr><td>Destroy key</td><td>✅</td><td>✅</td><td>✅</td></tr>
<tr><td>Sign hash</td><td>✅</td><td>✅</td><td>✅</td></tr>
<tr><td>Verify hash</td><td>✅</td><td>✅</td><td>✅</td></tr>
<tr><td>Asymmetric encrypt</td><td>✅</td><td>❌</td><td>❌</td></tr>
<tr><td>Asymmetric decrypt</td><td>✅</td><td>❌</td><td>❌</td></tr>
</tbody></table>
<h3><a class="header" href="#algorithm-support" id="algorithm-support">Algorithm support</a></h3>
<h4><a class="header" href="#hash-algorithms" id="hash-algorithms">Hash algorithms</a></h4>
<table><thead><tr><th>Algorithm</th><th>Mbed Crypto provider</th><th>PKCS 11 provider</th><th>TPM 2.0 provider</th></tr></thead><tbody>
<tr><td>MD2</td><td>❌</td><td>❌</td><td>❌</td></tr>
<tr><td>MD4</td><td>❌</td><td>❌</td><td>❌</td></tr>
<tr><td>MD5</td><td>❌</td><td>❌</td><td>❌</td></tr>
<tr><td>RIPEMD160</td><td>❌</td><td>❌</td><td>❌</td></tr>
<tr><td>SHA-1</td><td>❌</td><td>❌</td><td>✅</td></tr>
<tr><td>SHA-224</td><td>❌</td><td>❌</td><td>❌</td></tr>
<tr><td>SHA-256</td><td>✅</td><td>✅</td><td>✅</td></tr>
<tr><td>SHA-384</td><td>❌</td><td>❌</td><td>✅</td></tr>
<tr><td>SHA-512</td><td>❌</td><td>❌</td><td>✅</td></tr>
<tr><td>SHA-512-224</td><td>❌</td><td>❌</td><td>❌</td></tr>
<tr><td>SHA-512-256</td><td>❌</td><td>❌</td><td>❌</td></tr>
<tr><td>SHA3-224</td><td>❌</td><td>❌</td><td>❌</td></tr>
<tr><td>SHA3-256</td><td>❌</td><td>❌</td><td>✅</td></tr>
<tr><td>SHA3-384</td><td>❌</td><td>❌</td><td>✅</td></tr>
<tr><td>SHA3-512</td><td>❌</td><td>❌</td><td>✅</td></tr>
</tbody></table>
<h4><a class="header" href="#asymmetric-signing-algorithms" id="asymmetric-signing-algorithms">Asymmetric signing algorithms</a></h4>
<table><thead><tr><th>Algorithm</th><th>Mbed Crypto provider</th><th>PKCS 11 provider</th><th>TPM 2.0 provider</th></tr></thead><tbody>
<tr><td>RSA PKCS 1v5 with hash</td><td>✅</td><td>✅</td><td>✅</td></tr>
<tr><td>Raw RSA PKCS 1v5</td><td>❌</td><td>❌</td><td>❌</td></tr>
<tr><td>RSA PSS</td><td>❌</td><td>❌</td><td>❌</td></tr>
<tr><td>ECDSA</td><td>❌</td><td>❌</td><td>✅</td></tr>
<tr><td>ECDSA with any hash</td><td>❌</td><td>❌</td><td>❌</td></tr>
<tr><td>Deterministic ECDSA</td><td>❌</td><td>❌</td><td>❌</td></tr>
</tbody></table>
<h4><a class="header" href="#asymmetric-encryption-algorithms" id="asymmetric-encryption-algorithms">Asymmetric encryption algorithms</a></h4>
<table><thead><tr><th>Algorithm</th><th>Mbed Crypto provider</th><th>PKCS 11 provider</th><th>TPM 2.0 provider</th></tr></thead><tbody>
<tr><td>RSA PKCS 1v5</td><td>✅</td><td>❌</td><td>❌</td></tr>
<tr><td>Raw OAEP</td><td>✅</td><td>❌</td><td>❌</td></tr>
</tbody></table>
<p><em>Copyright 2020 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#parsec-api-coverage-within-client-libraries" id="parsec-api-coverage-within-client-libraries">Parsec API coverage within client libraries</a></h1>
<p>The current interface contracts defined for communication between Parsec and its clients is tracking
the <a href="https://developer.arm.com/architectures/security-architectures/platform-security-architecture/documentation">PSA Cryptography API version
1.0</a>.
This page describes the current state of support within clients for the operations, attributes and
options that are defined in that specification and for Parsec-related functionality (e.g. support
for various providers).</p>
<p>For an overview of the functionality supported by the service, see the <a href="service_api_coverage.html">service API coverage
page</a>.</p>
<p><strong>Note:</strong> Only client libraries that are developed by the Parsec organisation are represented in the
tables below. This does not guarantee or imply the same amount of support within other libraries. We
encourage each library author to publish their own coverage figures in their format of choice. Links
will be added here for any other such coverage report.</p>
<h2><a class="header" href="#provider-support" id="provider-support">Provider support</a></h2>
<table><thead><tr><th>Provider</th><th>Rust client</th></tr></thead><tbody>
<tr><td>Mbed Crypto</td><td>✅</td></tr>
<tr><td>PKCS11</td><td>✅</td></tr>
<tr><td>TPM 2.0</td><td>✅</td></tr>
</tbody></table>
<h2><a class="header" href="#operation-support-1" id="operation-support-1">Operation support</a></h2>
<table><thead><tr><th>Operation</th><th>Rust client</th></tr></thead><tbody>
<tr><td>Import key</td><td>✅</td></tr>
<tr><td>Generate key</td><td>✅</td></tr>
<tr><td>Export public key</td><td>✅</td></tr>
<tr><td>Export key</td><td>✅</td></tr>
<tr><td>Destroy key</td><td>✅</td></tr>
<tr><td>Sign hash</td><td>✅</td></tr>
<tr><td>Verify hash</td><td>✅</td></tr>
<tr><td>Asymmetric encrypt</td><td>✅</td></tr>
<tr><td>Asymmetric decrypt</td><td>✅</td></tr>
</tbody></table>
<h2><a class="header" href="#algorithm-support-1" id="algorithm-support-1">Algorithm support</a></h2>
<h3><a class="header" href="#hash-algorithms-1" id="hash-algorithms-1">Hash algorithms</a></h3>
<table><thead><tr><th>Algorithm</th><th>Rust client</th></tr></thead><tbody>
<tr><td>MD2</td><td>✅</td></tr>
<tr><td>MD4</td><td>✅</td></tr>
<tr><td>MD5</td><td>✅</td></tr>
<tr><td>RIPEMD160</td><td>✅</td></tr>
<tr><td>SHA-1</td><td>✅</td></tr>
<tr><td>SHA-224</td><td>✅</td></tr>
<tr><td>SHA-256</td><td>✅</td></tr>
<tr><td>SHA-384</td><td>✅</td></tr>
<tr><td>SHA-512</td><td>✅</td></tr>
<tr><td>SHA-512-224</td><td>✅</td></tr>
<tr><td>SHA-512-256</td><td>✅</td></tr>
<tr><td>SHA3-224</td><td>✅</td></tr>
<tr><td>SHA3-256</td><td>✅</td></tr>
<tr><td>SHA3-384</td><td>✅</td></tr>
<tr><td>SHA3-512</td><td>✅</td></tr>
</tbody></table>
<h3><a class="header" href="#asymmetric-signing-algorithms-1" id="asymmetric-signing-algorithms-1">Asymmetric signing algorithms</a></h3>
<table><thead><tr><th>Algorithm</th><th>Rust client</th></tr></thead><tbody>
<tr><td>RSA PKCS 1v5 with hash</td><td>✅</td></tr>
<tr><td>Raw RSA PKCS 1v5</td><td>✅</td></tr>
<tr><td>RSA PSS</td><td>✅</td></tr>
<tr><td>ECDSA</td><td>✅</td></tr>
<tr><td>ECDSA with any hash</td><td>✅</td></tr>
<tr><td>Deterministic ECDSA</td><td>✅</td></tr>
</tbody></table>
<h3><a class="header" href="#asymmetric-encryption-algorithms-1" id="asymmetric-encryption-algorithms-1">Asymmetric encryption algorithms</a></h3>
<table><thead><tr><th>Algorithm</th><th>Rust client</th></tr></thead><tbody>
<tr><td>RSA PKCS 1v5</td><td>✅</td></tr>
<tr><td>RSA OAEP with hash</td><td>✅</td></tr>
</tbody></table>
<p><em>Copyright 2020 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#parsec-threat-model" id="parsec-threat-model">Parsec Threat Model</a></h1>
<p>This document presents the generic Parsec Threat Model in a multi-tenant environment.</p>
<p>Parsec could also be deployed in an environment where all clients trust each other and there is no
Identity Provider present, and this would lead to some changes to the Threat Model. <em>These changes
will be written in italic.</em></p>
<h2><a class="header" href="#dataflow-diagram" id="dataflow-diagram">Dataflow Diagram</a></h2>
<p><img src="threat_model/diagrams/dataflow_diagram.png" alt="Dataflow Diagram" /></p>
<h2><a class="header" href="#assumptions" id="assumptions">Assumptions</a></h2>
<p>Basic requirements based on which the service can operate securely. Mitigations can be implemented
to make the system more resilient, but if some of these assumptions are not met, the security stance
of the service cannot be guaranteed.</p>
<ol>
<li>The hardware modules are physically and functionally secure. Only trusted agents can physically
access the system.</li>
<li>The service is configured and started by a trusted administrator.</li>
<li>The OS can be trusted to enforce access-control over critical resources (configuration file, key
info mappings, communication socket, etc.) and inter-process communication mechanisms.</li>
<li>Users with privilege rights are trusted to exercise them in a non-malicious way.</li>
<li>The authentication tokens are stored with confidentiality by the clients. <em>(N/A)</em></li>
<li>There is a trusted Identity Provider available. <em>(N/A)</em></li>
</ol>
<h2><a class="header" href="#assets" id="assets">Assets</a></h2>
<p>What we want to protect. Each one of these has a combination of security properties:
Confidentiality, Integrity and Availability. The assets are labelled so that it can be seen in the
threat tables below which ones are impacted by each threat.</p>
<h3><a class="header" href="#authentication-token---as1" id="authentication-token---as1">Authentication Token - AS1</a></h3>
<p>The Client Library gets its Authentication Token from the Identity Provider. It is signed by the
IP's private key and sent by the Client Library on each request. Parsec verifies the Authentication
Token using the IP's public key.</p>
<p><strong>Confidentiality</strong> : if known (the authentication token), an attacker could impersonate a specific
application and execute operations in their name.</p>
<p><em>Not applicable for deployments with no Identity Provider. In a deployment without an Identity
Provider tenants will still have an identity in the form of an application name, but all entities in
the system are trusted not to use identities of other tenants and so confidentiality is not
critical.</em></p>
<h3><a class="header" href="#identity-provider-public-key--as2" id="identity-provider-public-key--as2">Identity Provider Public Key- AS2</a></h3>
<p>The IP's public certificate is sent to the service periodically. It is used by the service to verify
the authentication tokens.</p>
<p><strong>Integrity</strong> : if sent by a malicious IP, attackers could then sign their own application
identities and Parsec will verify them successfully. If they know the Authentication Token of
clients, they can impersonate them.</p>
<p><strong>Availability</strong> : Parsec needs it in order to execute a request.</p>
<p><em>Not applicable for deployments with no Identity Provider.</em></p>
<h3><a class="header" href="#private-keys--as3" id="private-keys--as3">Private Keys- AS3</a></h3>
<p>Private keys created by Parsec on behalf of its clients. They should be stored on hardware and never
be extractable.</p>
<p><strong>Confidentiality, Integrity and Availability</strong> : by nature.</p>
<h3><a class="header" href="#clients-data--as4" id="clients-data--as4">Client's data- AS4</a></h3>
<p>Data sent by the client as part of a request or data about a client processed by the service. This
could appear in logs.</p>
<p><strong>Confidentiality</strong> : some of the client's data could be confidential (example: a buffer to
encrypt).</p>
<p><strong>Integrity</strong> : the data should not be modifiable by attackers. Parsec should be sure that the
source is trusted, and that the client is not being impersonated.</p>
<p><strong>Availability</strong> : the client should be able to access its stored data in a certain amount of time.</p>
<h3><a class="header" href="#configuration-data--as5" id="configuration-data--as5">Configuration data- AS5</a></h3>
<p>Data stored in the configuration file, read at each reloading of Parsec to instantiate components.</p>
<p><strong>Confidentiality</strong> : the data contains secrets like the user pin of the PKCS 11 device or the owner
hierarchy password of the TPM device.</p>
<p><strong>Integrity</strong> : the data should only be modified by a trusted Parsec administrator.</p>
<p><strong>Availability</strong> : the data should be available when loading or re-loading Parsec.</p>
<h3><a class="header" href="#availability-of-the-service--as6" id="availability-of-the-service--as6">Availability of the service- AS6</a></h3>
<p>General asset to describe the fact that each client's request should be done in a sane amount of
time. The service should be available at any given point from the moment it is started by the
administrator.</p>
<h3><a class="header" href="#key-triple-mappings--as7" id="key-triple-mappings--as7">Key Triple Mappings- AS7</a></h3>
<p>Data containing the mapping between a Key Triple (application name, provider ID, key name) and the
key attributes with a provider-specific identifier of the key. For the Mbed Crypto and PKCS11
providers this is an ID number, for the TPM provider this is the wrapped key.</p>
<p><strong>Integrity</strong> : Parsec expects this data to be valid.</p>
<p><strong>Availability</strong> : the data should be available when Parsec needs the specific key.</p>
<h3><a class="header" href="#logs--as8" id="logs--as8">Logs- AS8</a></h3>
<p>Data stored in logs emitted by any component of the stack.</p>
<p><strong>Confidentiality</strong> : the logs can contain confidential information of different parts of the
service.</p>
<p><strong>Integrity</strong> : the integrity of the logs is essential to prove that some events took place in
Parsec.</p>
<p><strong>Availability</strong> : the logs should be available for reading and writing when needed.</p>
<h2><a class="header" href="#attackers" id="attackers">Attackers</a></h2>
<p>Each dataflow is analysed from an attacker's perspective using STRIDE method. Nothing is supposed on
the different components.</p>
<p>In the following tables are present the type of each possible threat, its description, its
mitigation status and the assets impacted. A threat can be unmitigated (U), mitigated within the
service (M) or mitigated through operational requirements (O). The assumptions context applies for
all threats but when one of them is particularly relevant, it will be noted with ASUM.</p>
<p><em>In deployments without an Identity Provider, the A1, A2 and A10 attackers are not considered in
scope, dependent on the O-10 mitigation being deployed.</em></p>
<h3><a class="header" href="#attacker-client-request---a1" id="attacker-client-request---a1">Attacker &quot;Client Request&quot; - A1</a></h3>
<p>This attacker uses the existing Listener endpoint, created by the service, to communicate with it.</p>
<p><em>Not applicable for deployments with no Identity Provider.</em></p>
<table><thead><tr><th></th><th>Description</th><th>Mitigation</th><th>Assets</th></tr></thead><tbody>
<tr><td>S</td><td>An attacker uses another client's authentication token. He can then have access (reference) to any of the impersonated client's keys and execute any operation in their name.</td><td>U-2</td><td>AS3</td></tr>
<tr><td>S</td><td>An attacker uses brute-force on the AUTH field of the request until he does not have an AuthenticationError response status to then deduce a valid authentication token.</td><td>M-2</td><td>AS1</td></tr>
<tr><td>T</td><td>An attacker modifies the valid request of another client to modify the operation and make it non-secure.</td><td>M-3</td><td>AS4</td></tr>
<tr><td>R</td><td>A client denies the authorship of a request.</td><td>M-4</td><td></td></tr>
<tr><td>I</td><td>An attacker can read the confidential information of a request from another client.</td><td>M-3</td><td>AS1, AS4</td></tr>
<tr><td>I</td><td>An attacker steals the authentication token from a client's request to then execute any operation in their name.</td><td>M-3</td><td>AS4, AS3</td></tr>
<tr><td>D</td><td>An attacker modifies the valid request of another client to modify the operation and make it fail.</td><td>M-3</td><td>AS6</td></tr>
<tr><td>D</td><td>An attacker overloads/crashes the system and thus prevents any other user from making use of the service.</td><td>Crashes: M-0, M-5 Overloads: U-0</td><td>AS6</td></tr>
<tr><td>E</td><td>A malicious request, formatted in a specific way, triggers remote code execution in Parsec privilege level.</td><td>U-3, M-5</td><td>All</td></tr>
<tr><td>E</td><td>A malicious request exploits a vulnerability in the software stack and leads to an attacker having Parsec privilege level on key management in the underlying hardware.</td><td>U-3, M-5</td><td>AS3, AS6</td></tr>
</tbody></table>
<h3><a class="header" href="#attacker-service-response---a2" id="attacker-service-response---a2">Attacker &quot;Service Response&quot; - A2</a></h3>
<p>This attacker uses the existing Listener endpoint, created by the service, to communicate with the
client. It can also create a spoofed endpoint, mimicking the service's one.</p>
<p>For protection of the clients' assets, please check the Parsec Clients Threat Models.</p>
<p><em>Not applicable for deployments with no Identity Provider.</em></p>
<table><thead><tr><th></th><th>Description</th><th>Mitigation</th><th>Assets</th></tr></thead><tbody>
<tr><td>S</td><td>An attacker impersonates the Parsec service: clients share their data with a malicious entity.</td><td>O-2, O-9</td><td>AS3, AS4, AS6</td></tr>
<tr><td>T</td><td>An attacker modifies the response of another client to change its body or its header and thus alter the type, content or status of the response.</td><td>M-3</td><td>AS4</td></tr>
<tr><td>R</td><td>A client denies that the response was indeed sent by the Parsec service.</td><td>O-2, M-4, O-9</td><td></td></tr>
<tr><td>I</td><td>An attacker can read the content of a response.</td><td>M-3</td><td>AS4</td></tr>
<tr><td>I</td><td>The response code of a request gives too much information about the way the data is processed by the service that an attacker can use for an attack.</td><td>M-1</td><td>Depends on the attack</td></tr>
<tr><td>D</td><td>An attacker modifies the valid response of another client to pretend it failed or succeeded.</td><td>M-3</td><td>AS6</td></tr>
<tr><td>D</td><td>An attacker modifies the response in such a way that it leads the client to crash.</td><td>M-3</td><td></td></tr>
<tr><td>E</td><td>An attacker modifies the response in such a way that it leads to code execution in the client sandbox at the same level as the client.</td><td>M-3</td><td></td></tr>
</tbody></table>
<h3><a class="header" href="#attacker-os-signal---a3" id="attacker-os-signal---a3">Attacker &quot;OS Signal&quot; - A3</a></h3>
<p>This attacker has the capability of sending signals to the Parsec process. For example, on a Linux
machine a <code>SIGINT</code> signal.</p>
<table><thead><tr><th></th><th>Description</th><th>Mitigation</th><th>Assets</th></tr></thead><tbody>
<tr><td>S</td><td>N/A</td><td></td><td></td></tr>
<tr><td>T</td><td>A <code>SIGHUP</code> is modified by an attacker into <code>SIGTERM</code> or the other way around.</td><td>ASUM-3</td><td>AS6</td></tr>
<tr><td>R</td><td>N/A</td><td></td><td></td></tr>
<tr><td>I</td><td>N/A</td><td></td><td></td></tr>
<tr><td>D</td><td>An attacker can kill the Parsec service, gracefully or not or trigger an infinite loop of configuration reloads.</td><td>O-0</td><td>AS6</td></tr>
<tr><td>E</td><td>N/A</td><td></td><td></td></tr>
</tbody></table>
<h3><a class="header" href="#attacker-service-operation---a4" id="attacker-service-operation---a4">Attacker &quot;Service Operation&quot; - A4</a></h3>
<p>This attacker communicates with the security hardware on the platform using the operating system
interfaces.</p>
<table><thead><tr><th></th><th>Description</th><th>Mitigation</th><th>Assets</th></tr></thead><tbody>
<tr><td>S</td><td>An attacker directly drives the platform hardware to execute commands on it.</td><td>O-8</td><td>AS3, AS6</td></tr>
<tr><td>T</td><td>An attacker modifies the commands sent to hardware modules.</td><td>O-8, U-3</td><td>AS3, AS6</td></tr>
<tr><td>R</td><td>Commands cannot be proven to have originated in the service.</td><td>M-4</td><td></td></tr>
<tr><td>I</td><td>An attacker can read the content of commands to the hardware.</td><td>O-8, U-3</td><td>AS3, AS4, AS5</td></tr>
<tr><td>D</td><td>An attacker modifies the commands sent to the hardware to make them fail.</td><td>O-8, U-3</td><td>AS6</td></tr>
<tr><td>D</td><td>Attacker causes the underlying hardware to fail or be generally unusable.</td><td>O-8, U-3</td><td>AS6</td></tr>
<tr><td>D</td><td>Attacker disrupts the software stack that drives the hardware (e.g. replaces or removes PKCS 11 dynamic libraries).</td><td>O-8, U-3</td><td>AS6</td></tr>
<tr><td>E</td><td>An attacker uses the configured state of a hardware module to make operations with a higher privilege on it.</td><td>O-8, U-3, U-4</td><td>AS3, AS6</td></tr>
</tbody></table>
<h3><a class="header" href="#attacker-hardware-result---a5" id="attacker-hardware-result---a5">Attacker &quot;Hardware Result&quot; - A5</a></h3>
<p>This attacker communicates with the service using the operating system interfaces for hardware. It
can also create a spoofed hardware interface.</p>
<table><thead><tr><th></th><th>Description</th><th>Mitigation</th><th>Assets</th></tr></thead><tbody>
<tr><td>S</td><td>An attacker impersonates a hardware module or uses a malicious module plugged to the machine.</td><td>O-1, ASUM-2</td><td>AS4, AS6</td></tr>
<tr><td>T</td><td>An attacker modifies the response of a hardware command.</td><td>O-8, U-3</td><td>AS4, AS6</td></tr>
<tr><td>R</td><td>Responses cannot be proven to originate from the hardware module.</td><td>M-4</td><td></td></tr>
<tr><td>I</td><td>An attacker can read the content of a command response.</td><td>U-3, O-8</td><td>AS3, AS4, AS5</td></tr>
<tr><td>D</td><td>An attacker modifies the valid command response to pretend it failed or succeeded.</td><td>U-3, O-8</td><td>AS6</td></tr>
<tr><td>E</td><td>A malicious command response, formatted in a specific way, triggers remote code execution in Parsec privilege level.</td><td>U-3, M-5, O-8</td><td>All</td></tr>
</tbody></table>
<h3><a class="header" href="#attacker-key-mapping-storage---a6" id="attacker-key-mapping-storage---a6">Attacker &quot;Key Mapping Storage&quot; - A6</a></h3>
<p>Attacker with access to the key info mapping stream generated by Key Info Managers when storing its
data and to the persistent storage mechanism used for this purpose.</p>
<table><thead><tr><th></th><th>Description</th><th>Mitigation</th><th>Assets</th></tr></thead><tbody>
<tr><td>S</td><td>An attacker stores spoofed key handles/material, e.g. allowing themselves to access keys they should not have access to.</td><td>O-3</td><td>AS3, AS6</td></tr>
<tr><td>T</td><td>An attacker modifies the data stored for a mapping to either divert another user to use a different key, or to allow himself access to some key.</td><td>O-3</td><td>AS3, AS6</td></tr>
<tr><td>R</td><td>The mappings cannot be proven to have been generated by the service.</td><td>M-4</td><td></td></tr>
<tr><td>I</td><td>Key handles could be leaked and thus used to access keys through other means.</td><td>O-3</td><td>AS3,AS4</td></tr>
<tr><td>D</td><td>An attacker could prevent the storage to be completed, e.g. by filling up the disk and running into space-related issues.</td><td>O-4</td><td>AS6</td></tr>
<tr><td>E</td><td>N/A</td><td></td><td></td></tr>
</tbody></table>
<h3><a class="header" href="#attacker-key-mapping-retrieval---a7" id="attacker-key-mapping-retrieval---a7">Attacker &quot;Key Mapping Retrieval&quot; - A7</a></h3>
<p>Attacker with access to the data stream returning to the Key Info Manager from its source of
persistent storage.</p>
<table><thead><tr><th></th><th>Description</th><th>Mitigation</th><th>Assets</th></tr></thead><tbody>
<tr><td>S</td><td>Attacker spoofs the existence of a mapping and makes the service use an incorrect or invalid key (handle).</td><td>M-6, O-3</td><td>AS3, AS4, AS6</td></tr>
<tr><td>T</td><td>An attacker alters the retrieval of stored material to change the key that is used for an operation initiated by either himself or some other user.</td><td>M-6</td><td>AS3, AS6</td></tr>
<tr><td>R</td><td>There is no way to guarantee that the mapping being retrieved was previously stored by the service.</td><td>M-4</td><td></td></tr>
<tr><td>I</td><td>An attacker can read the mapping in transit.</td><td>M-6</td><td>AS3</td></tr>
<tr><td>D</td><td>An attacker prevents the value from being read.</td><td>M-6</td><td>AS6</td></tr>
<tr><td>D</td><td>An attacker removes all stored values, preventing users from utilizing their keys.</td><td>O-3</td><td>AS6</td></tr>
<tr><td>D</td><td>A malicious key handle, formatted in a specific way, leads to a service crash.</td><td>O-3, M-5, U-3</td><td>AS6</td></tr>
<tr><td>E</td><td>A malicious key handle, formatted in a specific way, triggers remote code execution in Parsec privilege level.</td><td>O-3, M-5, U-3</td><td>All</td></tr>
</tbody></table>
<h3><a class="header" href="#attacker-logging---a8" id="attacker-logging---a8">Attacker &quot;Logging&quot; - A8</a></h3>
<p>Attacker with access to the log stream generated by the Parsec service and to the log file.</p>
<table><thead><tr><th></th><th>Description</th><th>Mitigation</th><th>Assets</th></tr></thead><tbody>
<tr><td>S</td><td>An attacker could write to the log file, pretending to be the Parsec service and dilute the true logs, potentially hiding errors or crashes.</td><td>O-5</td><td>AS6</td></tr>
<tr><td>S</td><td>An attacker uses the same logging façade mechanism to write on the logs from a malicious Parsec dependency.</td><td>M-7</td><td>AS6</td></tr>
<tr><td>T</td><td>Attacker can modify logs to hide/modify details about crashes, errors or any other suspicious activity.</td><td>O-5</td><td>AS6</td></tr>
<tr><td>T</td><td>An attacker can delete the log file, removing all evidence of previous activity.</td><td>O-5</td><td>AS6</td></tr>
<tr><td>R</td><td>There is no guarantee about the true origin of log messages.</td><td>O-5</td><td></td></tr>
<tr><td>I</td><td>Log messages can be read by an adversary and their contents can disclose information about the activity of other users.</td><td>O-5</td><td>AS1, AS4, AS5</td></tr>
<tr><td>D</td><td>An attacker prevents access to the logging system by the service putting it in a stall state or triggering errors/crashes.</td><td>O-5, O-4</td><td>AS6</td></tr>
<tr><td>E</td><td>N/A</td><td></td><td></td></tr>
</tbody></table>
<h3><a class="header" href="#attacker-configuration---a9" id="attacker-configuration---a9">Attacker &quot;Configuration&quot; - A9</a></h3>
<p>Attacker with access to the configuration file for the Parsec service or to the OS-provided
mechanism for reading it.</p>
<table><thead><tr><th></th><th>Description</th><th>Mitigation</th><th>Assets</th></tr></thead><tbody>
<tr><td>S</td><td>An adversary can spoof a configuration file, leading to the service operating in an ineffective state or not starting at all.</td><td>O-6</td><td>AS5, AS6</td></tr>
<tr><td>T</td><td>The configuration file set up by the administrator might be modified, leading to the service being ineffective or broken.</td><td>O-6</td><td>AS5, AS6</td></tr>
<tr><td>R</td><td>There are no guarantees that the person setting up the configuration file was authorised to do so.</td><td>O-6</td><td></td></tr>
<tr><td>I</td><td>The configuration file might, if read by an adversary, provide information that opens different attack avenues.</td><td>O-6</td><td>AS5</td></tr>
<tr><td>I</td><td>If the configuration file is tampered, information about the existing keys can be extracted through rogue providers.</td><td>O-6</td><td>AS5</td></tr>
<tr><td>D</td><td>Removing or altering the configuration file can lead to the Parsec service not starting or working in a broken state.</td><td>O-6</td><td>AS6</td></tr>
<tr><td>E</td><td>Parsing a malicious configuration file can lead to code execution at the Parsec privilege level.</td><td>M-5, U-3, O-6</td><td>All</td></tr>
</tbody></table>
<h3><a class="header" href="#attacker-identity-provider---a10" id="attacker-identity-provider---a10">Attacker &quot;Identity Provider&quot; - A10</a></h3>
<p>Attacker with access to the communication running from the Identity Provider to the Parsec service.</p>
<p><em>Not applicable for deployments with no Identity Provider.</em></p>
<table><thead><tr><th></th><th>Description</th><th>Mitigation</th><th>Assets</th></tr></thead><tbody>
<tr><td>S</td><td>The initial trust bundle can be spoofed, and an attacker can thus gain complete control over the service.</td><td>O-7</td><td>AS2 and then all</td></tr>
<tr><td>T</td><td>The trust bundle shared by the identity provider can be modified in transit to disrupt the operation of the service or take control of it.</td><td>M-3</td><td>AS2 and then all</td></tr>
<tr><td>R</td><td>The service cannot guarantee that the trust bundle it received comes from the trusted identity provider.</td><td>O-7</td><td></td></tr>
<tr><td>I</td><td>N/A - the trust bundle contains public information</td><td></td><td></td></tr>
<tr><td>D</td><td>If the communication path between identity provider and service is disrupted, the service will not be in a fully functional state as it will not be able to authenticate requests.</td><td>M-3</td><td>AS2, AS6</td></tr>
<tr><td>D</td><td>A malicious share bundle could trigger a parsing bug and lead the service to crash.</td><td>M-5, U-3</td><td>AS2, AS6</td></tr>
<tr><td>E</td><td>A malicious share bundle could trigger a parsing bug and lead to code execution at the Parsec privilege level.</td><td>M-5, U-3</td><td>All</td></tr>
</tbody></table>
<h3><a class="header" href="#attacker-local-memory---a11" id="attacker-local-memory---a11">Attacker &quot;Local Memory&quot; - A11</a></h3>
<p>Attacker with access to the local memory regions used by Parsec. This attacker can be another
process scheduled by the OS in the same timeframe than Parsec and reading the memory which was not
cleared.</p>
<table><thead><tr><th></th><th>Description</th><th>Mitigation</th><th>Assets</th></tr></thead><tbody>
<tr><td>I</td><td>The attacker can read all the confidential assets placed in local memory by the service.</td><td>U-5</td><td>AS1, AS2, AS4 and AS5</td></tr>
</tbody></table>
<h2><a class="header" href="#unmitigations" id="unmitigations">Unmitigations</a></h2>
<table><thead><tr><th>ID</th><th>Justification</th><th>Consequences</th></tr></thead><tbody>
<tr><td>0</td><td>An attacker can use all the threads of the service's thread pool, requesting for a time-consuming operation on each one of them, to leave the less amount of free time possible to other clients.</td><td>The requests take more time to execute.</td></tr>
<tr><td>2</td><td>The authentication token is stored with confidentiality by the clients. If it is stolen, the service cannot prevent access with it unless the token is revoked.</td><td>All the client's keys can be used, and exported if allowed by the key's policy.</td></tr>
<tr><td>3</td><td>Parsec dependencies are not checked for Security Vulnerabilities.</td><td>A vulnerability in one of Parsec dependency will also impact Parsec and the data Parsec shares with that dependency.</td></tr>
<tr><td>4</td><td>While Parsec is authenticated on the device, anyone can brute force a key ID to execute operations with the key. Unmitigated for the PKCS 11 Provider: all sessions share the login state; if one session logs in then all other opened sessions will also be logged in. Other sessions only need a valid key ID to execute operations with private keys. Mitigated for the TPM Provider: each key is protected by a long, random authentication value, generated by the TPM</td><td>All the client's PKCS 11 keys can be used with PKCS 11 operations.</td></tr>
<tr><td>5</td><td>Parsec does not currently clear sensitive data in memory after use. <a href="https://github.com/parallaxsecond/parsec/issues/122">This is looked at here</a>.</td><td>The assets in local memory are exposed.</td></tr>
</tbody></table>
<h2><a class="header" href="#mitigations" id="mitigations">Mitigations</a></h2>
<table><thead><tr><th>ID</th><th>Justification</th><th>Details</th></tr></thead><tbody>
<tr><td>0</td><td>Parsec uses a thread pool with a configurable amount of threads to limit the number of concurrent operations it can support so that the machine is not overloaded.</td><td><a href="https://github.com/parallaxsecond/parsec/commit/e87984c4d3eaafa1a1cb977dceadf773aca1f7db">Done</a></td></tr>
<tr><td>1</td><td>Response statuses are audited to not give too much information to the client.</td><td><a href="https://github.com/parallaxsecond/parsec-interface-rs/issues/59">Open</a></td></tr>
<tr><td>2</td><td>The authenticators should only allow authentication tokens that are secure enough that brute-force attacks are not feasible.</td><td>Parsec does not use an authenticator in a deployment without an Identity Provider.</td></tr>
<tr><td>3</td><td>Listener implementations use an IPC mechanism respecting confidentiality and integrity of messages transmitted between the clients and the service (once the initial connection has been made).</td><td>Unix Domain Socket Listener: the sockets used on the client and service side for the communication are represented by file descriptors that are only accessible by those processes.</td></tr>
<tr><td>4</td><td>The following events are logged by the service with information containing the application identity, time and date: &quot;new request received&quot;, &quot;response sent back&quot;, &quot;new mapping created&quot;, &quot;mapping is read from the persistent store&quot;, &quot;a hardware command is issued&quot; and &quot;a hardware command is received&quot;.</td><td><a href="https://github.com/parallaxsecond/parsec/pull/189">In progress for Parsec</a> and <a href="https://github.com/parallaxsecond/rust-tss-esapi/issues/86">open for TPM</a></td></tr>
<tr><td>5</td><td>Parsec is coded with safety in mind and is tested extensively.</td><td><a href="https://github.com/parallaxsecond/parsec-book/issues/35">Open</a></td></tr>
<tr><td>6</td><td>The <code>ManageKeyInfo</code> implementations communicate with its persistence storage backend through a mechanism respecting confidentiality, integrity and availability.</td><td>On-Disk Key Info Manager: the mappings are stored on-disk using the filesystem provided by the OS. OS file permissions are used.</td></tr>
<tr><td>7</td><td>Logging is configured to include the software component from where logs are generated.</td><td><a href="https://github.com/parallaxsecond/parsec/commit/aafd176b49dd01c3f08866d564f2fff092d1305e">Done</a></td></tr>
</tbody></table>
<h2><a class="header" href="#operational-mitigations" id="operational-mitigations">Operational mitigations</a></h2>
<table><thead><tr><th>ID</th><th>Justification</th></tr></thead><tbody>
<tr><td>0</td><td>A trusted administrator should start the service in such a way that un-privileged processes cannot send signals to the service.</td></tr>
<tr><td>1</td><td>A trusted administrator should check the validity of the providers and hardware modules written in the service's configuration before starting/reloading it.</td></tr>
<tr><td>2</td><td>Clients need to know from a trusted source that a trusted Parsec service is running on their machine so that they can trust the Listener endpoint.</td></tr>
<tr><td>3</td><td>Mappings should be put in a location that only the Parsec service and the trusted administrator can access.</td></tr>
<tr><td>4</td><td>The trusted administrator needs to be notified when any kind of resource is running out.</td></tr>
<tr><td>5</td><td>Parsec logs coming from the service binary should be redirected to a file that is only writable by the service and readable by the trusted administrator.</td></tr>
<tr><td>6</td><td>Parsec configuration file should be only writable by the trusted administrator and readable by the service.</td></tr>
<tr><td>7</td><td>The trusted administrator needs to check that during the boot process the trusted identity provider has successfully given the root trust bundle to the service.</td></tr>
<tr><td>8</td><td>The hardware descriptors should only be accessible by trusted privileged processes.</td></tr>
<tr><td>9</td><td>The Listener endpoint should be contained in a location that only the Parsec service and the trusted administrator can access (only they can create the endpoint).</td></tr>
<tr><td><em>10</em></td><td><em>A set of mutually trusted clients has restricted read-write access to the service IPC endpoint.</em></td></tr>
</tbody></table>
<p><em>Copyright 2020 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#recommendations-on-a-secure-parsec-deployment" id="recommendations-on-a-secure-parsec-deployment">Recommendations on a Secure Parsec Deployment</a></h1>
<p>The following recommendations should be applied in order for Parsec to respect some of the
operational mitigations. These recommendations have been thought of for a Linux system and should be
modified/ported for other operating systems. The linked <a href="threat_model/threat_model.html#operational-mitigations">operational
mitigations</a> are noted with <code>O-n</code>.</p>
<ul>
<li>The service must be running as the <code>parsec</code> user (O-0).</li>
<li>Key mappings must only be read/write by the <code>parsec</code> user (O-3).</li>
<li>The logs must be redirected to a file only readable by the <code>parsec</code> user (O-5).</li>
<li>The configuration file must only be read/write by the <code>parsec</code> user (O-6).</li>
<li>For the Domain Socket Listener, the socket must be in a folder with specific permissions (O-9).
The folder must be owned by the <code>parsec</code> user which must have read, write and execute rights on
it.
<ul>
<li>In a deployment <strong>without Identity Provider</strong>, the folder must be group owned by the
<code>parsec-clients</code> group which has only read and execute permission on it (O-10). Everyone else
must have no permission on the folder. The <code>parsec-clients</code> group is composed of mutually
trusted clients only.</li>
<li>In a deployment <strong>with Identity Provider</strong>, everyone else can have read and execute permission
on the folder.</li>
</ul>
</li>
<li>Before accessing the service, clients must check the permissions of the folder containing the
socket (O-2). The owner, group owner and permissions must be the same as the previous point,
depending on an Identity Provider is available or not.</li>
</ul>
<h1><a class="header" href="#using-systemd" id="using-systemd">Using systemd</a></h1>
<p>Installing Parsec using systemd with the unit files provided and <a href="threat_model/../parsec_service/install_parsec_linux.html">following the
guide</a> will make sure that the recommendations above are
respected.</p>
<p><em>Copyright 2020 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#parsec-rust-client-threat-model" id="parsec-rust-client-threat-model">Parsec Rust Client Threat Model</a></h1>
<p>This document presents the Threat Model for the Parsec Rust client crate. The interactions between
the Parsec client library and any external software components is assessed. Currently the presence
of an Identity Provider is not considered as part of the scheme due to uncertainty as to how the
dataflow would look in such a case and what security issues might arise. The threat model indirectly
covers a secondary use pattern, namely via a Secure Element Driver (SE Driver) that bridges between
Mbed Crypto and the Parsec client, allowing usage of the Rust stack from a C-language environment.</p>
<h2><a class="header" href="#dataflow-diagram-1" id="dataflow-diagram-1">Dataflow Diagram</a></h2>
<p><img src="threat_model/diagrams/rust_client_diagram.png" alt="Dataflow Diagram" /></p>
<h2><a class="header" href="#assumptions-1" id="assumptions-1">Assumptions</a></h2>
<p>Basic requirements based on which the client can be used securely. Mitigations can be implemented to
make the system more resilient, but if some of these assumptions are not met, the security implied
by Parsec cannot be guaranteed.</p>
<ol>
<li>The platform on which the client application is running is trusted by the client to host the
Parsec service</li>
<li>With the lack of an identity provider, all applications running in parallel on the platform that
could access the Parsec service are trusted to not interfere with or impersonate the client
application.</li>
<li>The client application obtains or generates a persistent name that it uses consistently for
accessing its service-side assets.</li>
</ol>
<h2><a class="header" href="#assets-1" id="assets-1">Assets</a></h2>
<p>What we want to protect. Each one of these has a combination of Security Property: Confidentiality,
Integrity and Availability. The assets are labelled so that it can be seen in the threat tables
below which ones are impacted by each threat.</p>
<h3><a class="header" href="#application-identity---as1" id="application-identity---as1">Application Identity - AS1</a></h3>
<p>Ideally, the Client Library gets its Application Identity from the Identity Provider. However,
without an Identity Provider in the system applications are expected to handle their identities on
their own. The identity will be used by the service to partition the assets it stores for clients
into a namespace for each one.</p>
<p><strong>Confidentiality</strong> : if known (the authentication token), an attacker could impersonate a specific
application and execute operations in their name.</p>
<h3><a class="header" href="#clients-data--as2" id="clients-data--as2">Client’s data- AS2</a></h3>
<p>Data sent through the client as part of a request to the service.</p>
<p><strong>Confidentiality</strong> : some of the client’s data could be confidential (example: a buffer to
encrypt).</p>
<p><strong>Integrity</strong> : the data should not be modifiable by attackers. The client should be certain that it
is interacting with the legitimate Parsec service.</p>
<h3><a class="header" href="#configuration-data--as3" id="configuration-data--as3">Configuration data- AS3</a></h3>
<p>Configuration data passed by the client application to the library. There is some overlap between
the configuration data and the application identity, as the identity is stored within the client
library and could thus be considered part of its configuration data.</p>
<p><strong>Confidentiality</strong> : if known (the authentication token), an attacker could impersonate a specific
application and execute operations in their name.</p>
<p><strong>Integrity</strong> : the data should only be modified by the client application as doing otherwise might
prevent the client application from accessing Parsec functionality.</p>
<h3><a class="header" href="#clients-cryptographic-keys---as4" id="clients-cryptographic-keys---as4">Client’s cryptographic keys - AS4</a></h3>
<p>Keys provisioned by the client within the service.</p>
<p><strong>Confidentiality</strong> : (private) key material is sensitive data and should not be exposed.</p>
<p><strong>Integrity</strong> : neither public nor private key data should be modifiable by attackers.</p>
<p><strong>Availability</strong> : the client must always be able to use their cryptographic material.</p>
<h3><a class="header" href="#system-and-client-application-stability---as5" id="system-and-client-application-stability---as5">System and client application stability - AS5</a></h3>
<p>The application which is using the Parsec client library and the sytem as a whole must be kept
stable and responsive.</p>
<p><strong>Availability</strong> : the client application must not be crashed by the library in any way.</p>
<h2><a class="header" href="#attackers-1" id="attackers-1">Attackers</a></h2>
<p>Each dataflow is analysed from an attacker’s perspective using STRIDE method. Nothing is supposed
on the different components.</p>
<p>In the following tables are present the type of each possible threat, its description, its
mitigation status and the assets impacted. A threat can be unmitigated (U), mitigated (M) or
operational (O). The assumptions context applies for all threats but when one of them is
particularly relevant, it will be noted with ASUM.</p>
<h3><a class="header" href="#attacker-request-to-service---a1" id="attacker-request-to-service---a1">Attacker “Request to Service” - A1</a></h3>
<p>This attacker uses the inter-process endpoint, presumably created by the service, to interfere with
the communication between client and service.</p>
<table><thead><tr><th></th><th>Description</th><th>Mitigation</th><th>Assets</th></tr></thead><tbody>
<tr><td>S</td><td>An attacker impersonates the service by establishing an IPC endpoint that spoofs the one used by Parsec to exfiltrate any data found in requests.</td><td>O-0, O-1</td><td>AS1, AS2, AS4</td></tr>
<tr><td>S</td><td>An attacker impersonates the service and responds to requests using bogus or malicious data.</td><td>O-0, O-1</td><td>AS2</td></tr>
<tr><td>T</td><td>The attacker modifies the data sent or received by the client while it is in transit through the IPC.</td><td>M-0</td><td>AS2, AS4</td></tr>
<tr><td>R</td><td>The service denies having sent responses to or received some requests from the client.</td><td>U-1, O-3</td><td></td></tr>
<tr><td>I</td><td>An attacker obtains requests sent by the client by sniffing the IPC traffic or spoofing the endpoint.</td><td>M-0, O-1</td><td>AS2, AS4</td></tr>
<tr><td>D</td><td>An attacker could remove the IPC endpoint or block traffic through it.</td><td>O-1</td><td>AS4</td></tr>
<tr><td>D</td><td>An attacker could swamp the service with requests so that the client's requests take a long time to service.</td><td>O-2</td><td>AS2</td></tr>
<tr><td>D</td><td>An attacker could tamper with incoming responses to exploit vulnerabilities in the client library and crash the client.</td><td>M-0, M-1, U-0</td><td>AS5</td></tr>
<tr><td>E</td><td>An attacker could tamper with incoming responses to exploit vulnerabilities in the client library and run code in the same user as the client.</td><td>M-0, M-1, U-0</td><td>AS5</td></tr>
</tbody></table>
<h3><a class="header" href="#attacker-library-memory---a2" id="attacker-library-memory---a2">Attacker “Library Memory” - A2</a></h3>
<p>This attacker gains access to memory released by the client library, containing potentially
sensitive information.</p>
<table><thead><tr><th></th><th>Description</th><th>Mitigation</th><th>Assets</th></tr></thead><tbody>
<tr><td>I</td><td>An attacker reads requests and responses from memory.</td><td>U-2</td><td>AS2, AS4</td></tr>
<tr><td>I</td><td>An attacker reads out the application identity from memory.</td><td>U-2</td><td>AS1</td></tr>
</tbody></table>
<h2><a class="header" href="#unmitigations-1" id="unmitigations-1">Unmitigations</a></h2>
<table><thead><tr><th>ID</th><th>Justification</th><th>Consequences</th></tr></thead><tbody>
<tr><td>0</td><td>Client library dependencies are not checked for Security Vulnerabilities.</td><td>A vulnerability in one of the Parsec client dependencies will also impact the client application and the data it shares with the Parsec library.</td></tr>
<tr><td>1</td><td>Authenticity of responses is not ensured through a MAC or asymmetric signature – it relies on trust in the platform administrator.</td><td>Any response from the service could have been spoofed or altered by any entity with sufficient capabilities.</td></tr>
<tr><td>2</td><td>Parsec does not currently clear sensitive data in memory after use. <a href="https://github.com/parallaxsecond/parsec-client-rust/issues/9">This is looked at here</a>.</td><td>Any data that passes through the client library could be read after the memory is released.</td></tr>
</tbody></table>
<h2><a class="header" href="#mitigations-1" id="mitigations-1">Mitigations</a></h2>
<table><thead><tr><th>ID</th><th>Justification</th><th>Details</th></tr></thead><tbody>
<tr><td>0</td><td>Parsec interface uses an IPC mechanism respecting confidentiality and integrity of messages transmitted between the clients and the service (once the initial connection has been made).</td><td>Unix Domain Socket: the sockets used on the client and service side for the communication are represented by file descriptors that are only accessible by those processes.</td></tr>
<tr><td>1</td><td>The Parsec client is coded with safety in mind and is tested extensively.</td><td><a href="https://github.com/parallaxsecond/parsec-book/issues/35">Open</a></td></tr>
</tbody></table>
<h2><a class="header" href="#operational-mitigations-1" id="operational-mitigations-1">Operational mitigations</a></h2>
<table><thead><tr><th>ID</th><th>Justification</th></tr></thead><tbody>
<tr><td>0</td><td>Clients need to know from a trusted source that a trusted Parsec service is running on their machine so that they can trust the IPC endpoint.</td></tr>
<tr><td>1</td><td>The IPC endpoint should be secured so that only privileged users can remove or alter it.</td></tr>
<tr><td>2</td><td>A set of mutually trusted clients has restricted read-write access to the service IPC endpoint.</td></tr>
<tr><td>3</td><td>The Parsec service is configured to display detailed logs about all requests made by clients.</td></tr>
</tbody></table>
<p><em>Copyright 2020 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#parsec-for-users" id="parsec-for-users">Parsec for users</a></h1>
<h2><a class="header" href="#how-to-use-parsec" id="how-to-use-parsec">How to use Parsec</a></h2>
<p>On a system where Parsec is installed, it can easily be used with a Parsec Client Library. Those
libraries communicate with the Parsec service and integrate with the rest of the software
idiomatically.</p>
<p>Parsec Client Libraries are available in the following languages:</p>
<ul>
<li><a href="https://docs.rs/parsec-client/*/parsec_client/">Rust</a></li>
<li><a href="https://github.com/parallaxsecond/parsec-se-driver">C</a>: support is currently being built to use
Parsec through the PSA Crypto API</li>
<li><a href="https://github.com/parallaxsecond/parsec-client-go">Go</a> (not currently working but contributions
are welcome!)</li>
</ul>
<p>Please <a href="parsec_client/writing_library.html">contribute</a> to add more Parsec Client Libraries in the
languages that you want!</p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#parsec-for-client-library-developers" id="parsec-for-client-library-developers">Parsec for client library developers</a></h1>
<p>This section offers the information needed for building Parsec client libraries. The topics covered
are:</p>
<ul>
<li><a href="parsec_client/operations">Operations</a> - structured description of all Parsec operations; this subsection
provides the official documentation for the API</li>
<li><a href="parsec_client/api_overview.html">API overview</a> - overview of the API and the design principles behind it</li>
<li><a href="parsec_client/status_codes.html">Status codes</a> - comprehensive list of response codes returned by the service and
their meaning</li>
<li><a href="parsec_client/wire_protocol.html">Wire protocol</a> - detailed description of the representation and meaning of data
communicated between the client and service</li>
<li><a href="parsec_client/writing_library.html">Writing a new client library</a> - hints and tips for getting started with
developing a new client library</li>
</ul>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#operations" id="operations">Operations</a></h1>
<h2><a class="header" href="#introduction" id="introduction">Introduction</a></h2>
<p>This document provides links to full descriptions for all of the operations in the API. The
operations are defined in a format-neutral language where types can easily and implicitely be
translated to the specific operation implementation language used.</p>
<h2><a class="header" href="#status-note" id="status-note">Status Note</a></h2>
<p>This is preliminary documentation. It may be incomplete, and is subject to change without notice.
Some operations are listed without being linked to documentation pages. These operations are not
currently supported, but are intended for future roadmap. Only a small number of the PSA Crypto
operations are supported in the current version.</p>
<h2><a class="header" href="#identity-operations" id="identity-operations">Identity Operations</a></h2>
<p>Identity operations are not supported by the security service. These operations are reserved for use
only by the identity provider, which is a separate service in the system, but supports a common wire
protocol.</p>
<ul>
<li><a href="parsec_client/operations/add_client.html">AddClient</a></li>
<li><a href="parsec_client/operations/prove_client.html">ProveClient</a></li>
</ul>
<h2><a class="header" href="#core-operations" id="core-operations">Core Operations</a></h2>
<p>Core operations are non-cryptographic operations supported by the core provider. Set the
<strong>provider</strong> field of the request header to 0 (<code>0x00</code>) to invoke these operations.</p>
<h3><a class="header" href="#service-health" id="service-health">Service Health</a></h3>
<ul>
<li><a href="parsec_client/operations/ping.html">Ping</a></li>
</ul>
<h3><a class="header" href="#service-configuration" id="service-configuration">Service Configuration</a></h3>
<ul>
<li><a href="parsec_client/operations/list_providers.html">ListProviders</a></li>
<li><a href="parsec_client/operations/list_opcodes.html">ListOpcodes</a></li>
</ul>
<h3><a class="header" href="#trust" id="trust">Trust</a></h3>
<ul>
<li><a href="parsec_client/operations/share_trust_bundle.html">ShareTrustBundle</a></li>
</ul>
<h2><a class="header" href="#psa-crypto-operations" id="psa-crypto-operations">PSA Crypto Operations</a></h2>
<p>These operations are all derived from equivalent function definitions in the <a href="https://developer.arm.com/architectures/security-architectures/platform-security-architecture/documentation"><strong>PSA Crypto API
Specification</strong></a>.
Most of the documentation in this book directly come from the specification.</p>
<h3><a class="header" href="#key-management" id="key-management">Key Management</a></h3>
<ul>
<li><a href="parsec_client/operations/psa_import_key.html">PsaImportKey</a></li>
<li><a href="parsec_client/operations/psa_generate_key.html">PsaGenerateKey</a></li>
<li>PsaCopyKey</li>
<li><a href="parsec_client/operations/psa_destroy_key.html">PsaDestroyKey</a></li>
<li><a href="parsec_client/operations/psa_export_key.html">PsaExportKey</a></li>
<li><a href="parsec_client/operations/psa_export_public_key.html">PsaExportPublicKey</a></li>
</ul>
<h3><a class="header" href="#message-digests" id="message-digests">Message Digests</a></h3>
<ul>
<li>PsaHashCompute</li>
<li>PsaHashCompare</li>
<li>PsaHashOperationInit</li>
<li>PsaHashSetup</li>
<li>PsaHashUpdate</li>
<li>PsaHashFinish</li>
<li>PsaHashVerify</li>
<li>PsaHashAbort</li>
<li>PsaHashSuspend</li>
<li>PsaHashResume</li>
<li>PsaHashClone</li>
</ul>
<h3><a class="header" href="#message-authentication-codes-mac" id="message-authentication-codes-mac">Message Authentication Codes (MAC)</a></h3>
<ul>
<li>PsaMacCompute</li>
<li>PsaMacVerify</li>
<li>PsaMacOperationInit</li>
<li>PsaMacSignSetup</li>
<li>PsaMacVerifySetup</li>
<li>PsaMacUpdate</li>
<li>PsaMacSignFinish</li>
<li>PsaMacVerifyFinish</li>
<li>PsaMacAbort</li>
</ul>
<h3><a class="header" href="#unauthenticated-ciphers" id="unauthenticated-ciphers">Unauthenticated Ciphers</a></h3>
<ul>
<li>PsaCipherEncrypt</li>
<li>PsaCipherDecrypt</li>
<li>PsaCipherOperationInit</li>
<li>PsaCipherEncryptSetup</li>
<li>PsaCipherDecryptSetup</li>
<li>PsaCipherGenerateIv</li>
<li>PsaCipherSetIv</li>
<li>PsaCipherUpdate</li>
<li>PsaCipherFinish</li>
<li>PsaCipherAbort</li>
</ul>
<h3><a class="header" href="#authenticated-encryption-with-associated-data-aead" id="authenticated-encryption-with-associated-data-aead">Authenticated Encryption with Associated Data (AEAD)</a></h3>
<ul>
<li>PsaAeadEncrypt</li>
<li>PsaAeadDecrypt</li>
<li>PsaAeadOperationInit</li>
<li>PsaAeadEncryptSetup</li>
<li>PsaAeadDecryptSetup</li>
<li>PsaAeadGenerateNonce</li>
<li>PsaAeadSetNonce</li>
<li>PsaAeadSetLengths</li>
<li>PsaAeadUpdateAd</li>
<li>PsaAeadUpdate</li>
<li>PsaAeadFinish</li>
<li>PsaAeadVerify</li>
<li>PsaAeadAbort</li>
</ul>
<h3><a class="header" href="#key-derivation" id="key-derivation">Key Derivation</a></h3>
<ul>
<li>PsaKeyDerivationOperationInit</li>
<li>PsaKeyDerivationSetup</li>
<li>PsaKeyDerivationGetCapacity</li>
<li>PsaKeyDerivationSetCapacity</li>
<li>PsaKeyDerivationInputBytes</li>
<li>PsaKeyDerivationInputKey</li>
<li>PsaKeyDerivationOutputBytes</li>
<li>PsaKeyDerivationOutputKey</li>
<li>PsaKeyDerivationAbort</li>
</ul>
<h3><a class="header" href="#asymmetric-signature" id="asymmetric-signature">Asymmetric Signature</a></h3>
<ul>
<li>PsaSignMessage</li>
<li>PsaVerifyMessage</li>
<li><a href="parsec_client/operations/psa_sign_hash.html">PsaSignHash</a></li>
<li><a href="parsec_client/operations/psa_verify_hash.html">PsaVerifyHash</a></li>
</ul>
<h3><a class="header" href="#asymmetric-encryption" id="asymmetric-encryption">Asymmetric Encryption</a></h3>
<ul>
<li><a href="parsec_client/operations/psa_asymmetric_encrypt.html">PsaAsymmetricEncrypt</a></li>
<li><a href="parsec_client/operations/psa_asymmetric_decrypt.html">PsaAsymmetricDecrypt</a></li>
</ul>
<h3><a class="header" href="#key-agreement" id="key-agreement">Key Agreement</a></h3>
<ul>
<li>PsaRawKeyAgreement</li>
<li>PsaKeyDerivationKeyAgreement</li>
</ul>
<h3><a class="header" href="#random-number-generation" id="random-number-generation">Random Number Generation</a></h3>
<ul>
<li>PsaGenerateRandom</li>
</ul>
<h2><a class="header" href="#increasing-psa-api-coverage" id="increasing-psa-api-coverage">Increasing PSA API coverage</a></h2>
<p>You can help increase the coverage of the PSA Crypto API! See
<a href="parsec_client/operations/../../contributing/adding_new_operation_how_to.html">here</a> on how you can contribute.</p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#addclient" id="addclient">AddClient</a></h1>
<p>Placeholder page.</p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#listopcodes" id="listopcodes">ListOpcodes</a></h1>
<p>Gets a list of available opcodes supported by a Parsec provider. Opcode: 9 (<code>0x0009</code>)</p>
<h2><a class="header" href="#parameters" id="parameters">Parameters</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>provider_id</code></td><td>Unsigned integer</td><td>Provider for which the supported opcodes are requested.</td></tr>
</tbody></table>
<h2><a class="header" href="#results" id="results">Results</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>opcodes</code></td><td>Vector of unsigned integers</td><td>List of supported opcodes</td></tr>
</tbody></table>
<h2><a class="header" href="#specific-response-status-codes" id="specific-response-status-codes">Specific response status codes</a></h2>
<p>No specific response status codes returned.</p>
<h2><a class="header" href="#description" id="description">Description</a></h2>
<p>Gets a list of available opcodes supported by a Parsec provider.</p>
<h2><a class="header" href="#contract" id="contract">Contract</a></h2>
<p><a href="https://github.com/parallaxsecond/parsec-operations/blob/master/protobuf/list_opcodes.proto">Protobuf</a></p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#listproviders" id="listproviders">ListProviders</a></h1>
<p>Gets a prioritised list of available Parsec providers to be used by clients. Opcode: 8 (<code>0x0008</code>)</p>
<h2><a class="header" href="#parameters-1" id="parameters-1">Parameters</a></h2>
<p>No parameters are needed for this operation.</p>
<h2><a class="header" href="#results-1" id="results-1">Results</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>providers</code></td><td>Vector of <a href="parsec_client/operations/list_providers.html#providerinfo-type"><code>ProviderInfo</code></a></td><td>List of provider information</td></tr>
</tbody></table>
<h3><a class="header" href="#providerinfo-type" id="providerinfo-type">ProviderInfo type</a></h3>
<p>A <code>ProviderInfo</code> type contains the following members:</p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>uuid</code></td><td>String</td><td>Unique, permanent, identifier of the provider (version 4 UUID)</td></tr>
<tr><td><code>description</code></td><td>String</td><td>Short description of the provider</td></tr>
<tr><td><code>vendor</code></td><td>String</td><td>Provider vendor</td></tr>
<tr><td><code>version_maj</code></td><td>Unsigned integer</td><td>Provider implementation version major</td></tr>
<tr><td><code>version_min</code></td><td>Unsigned integer</td><td>Provider implementation version minor</td></tr>
<tr><td><code>version_rev</code></td><td>Unsigned integer</td><td>Provider implementation version revision number</td></tr>
<tr><td><code>id</code></td><td>Unsigned integer</td><td>Provider ID to use on the wire protocol to communicate with this provider</td></tr>
</tbody></table>
<h2><a class="header" href="#specific-response-status-codes-1" id="specific-response-status-codes-1">Specific response status codes</a></h2>
<p>No specific response status codes returned.</p>
<h2><a class="header" href="#description-1" id="description-1">Description</a></h2>
<p>The version triplet returned by this operation (<code>version_maj</code>, <code>version_min</code> and <code>version_rev</code>) is
the implementation version of the specific Parsec provider. For the Core Provider, this version is
the implementation version of the whole Parsec service.</p>
<p>The <code>providers</code> vector returned is in order of provider priority: the highest priority providers
come first. The core provider will always come last. The provider at position zero, if not the core
provider, can be treated as default provider by the client. Clients should still check the supported
opcodes of the provider, even the default one, as it might not implement the operations they want.</p>
<h2><a class="header" href="#contract-1" id="contract-1">Contract</a></h2>
<p><a href="https://github.com/parallaxsecond/parsec-operations/blob/master/protobuf/list_providers.proto">Protobuf</a></p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#ping" id="ping">Ping</a></h1>
<p>Determines whether the service is present and responsive on the expected endpoint. Opcode: 1
(<code>0x0001</code>)</p>
<h2><a class="header" href="#parameters-2" id="parameters-2">Parameters</a></h2>
<p>No parameters are needed for this operation.</p>
<h2><a class="header" href="#results-2" id="results-2">Results</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>wire_protocol_version_maj</code></td><td>Unsigned integer</td><td>Wire protocol version major</td></tr>
<tr><td><code>wire_protocol_version_min</code></td><td>Unsigned integer</td><td>Wire protocol version minor</td></tr>
</tbody></table>
<h2><a class="header" href="#specific-response-status-codes-2" id="specific-response-status-codes-2">Specific response status codes</a></h2>
<p>No specific response status codes returned.</p>
<h2><a class="header" href="#description-2" id="description-2">Description</a></h2>
<p>Clients should follow the following bootstrapping sequence if they want to switch to the highest
wire protocol version that the service support:</p>
<ol>
<li>Client requests a Ping operation using the wire protocol version <code>1.0</code>.</li>
<li>Service responds with the highest wire protocol version supported <code>x.y</code>.</li>
<li>Client can now use any wire protocol version up to and including <code>x.y</code> for further requests.</li>
</ol>
<h2><a class="header" href="#contract-2" id="contract-2">Contract</a></h2>
<p><a href="https://github.com/parallaxsecond/parsec-operations/blob/master/protobuf/ping.proto">Protobuf</a></p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#proveclient" id="proveclient">ProveClient</a></h1>
<p>Placeholder page.</p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#psadestroykey" id="psadestroykey">PsaDestroyKey</a></h1>
<p>Destroy a key. Opcode: 3 (<code>0x0003</code>)</p>
<h2><a class="header" href="#parameters-3" id="parameters-3">Parameters</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>key_name</code></td><td>String</td><td>Name of the key to erase</td></tr>
</tbody></table>
<h2><a class="header" href="#results-3" id="results-3">Results</a></h2>
<p>No values are returned by this operation.</p>
<h2><a class="header" href="#specific-response-status-codes-3" id="specific-response-status-codes-3">Specific response status codes</a></h2>
<ul>
<li><code>PsaErrorNotPermitted</code>: The key cannot be erased because it is read-only, either due to a policy
or due to physical restrictions.</li>
<li><code>PsaErrorCommunicationFailure</code>: There was an failure in communication with the cryptoprocessor.
The key material might still be present in the cryptoprocessor.</li>
<li><code>PsaErrorStorageFailure</code>: The storage operation failed. Implementations must make a best effort to
erase key material even in this situation, however, it might be impossible to guarantee that the
key material is not recoverable in such cases.</li>
<li><code>PsaErrorDataCorrupt</code>: The storage is corrupted. Implementations must make a best effort to erase
key material even in this situation, however, it might be impossible to guarantee that the key
material is not recoverable in such cases.</li>
<li><code>PsaErrorCorruptionDetected</code>: An unexpected condition which is not a storage corruption or a
communication failure occurred. The cryptoprocessor might have been compromised.</li>
</ul>
<h2><a class="header" href="#description-3" id="description-3">Description</a></h2>
<p>This function destroys a key from storage. This function also erases any metadata such as policies
and frees resources associated with the key. If a key is currently in use in a multi-part operation,
then destroying the key will cause the multi-part operation to fail.</p>
<h2><a class="header" href="#contract-3" id="contract-3">Contract</a></h2>
<p><a href="https://github.com/parallaxsecond/parsec-operations/blob/master/protobuf/psa_destroy_key.proto">Protobuf</a></p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#psaexportpublickey" id="psaexportpublickey">PsaExportPublicKey</a></h1>
<p>Export a public key or the public part of a key pair in binary format. Opcode: 7 (<code>0x0007</code>)</p>
<h2><a class="header" href="#parameters-4" id="parameters-4">Parameters</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>key_name</code></td><td>String</td><td>Name of the public key to export</td></tr>
</tbody></table>
<h2><a class="header" href="#results-4" id="results-4">Results</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>data</code></td><td>Vector of bytes</td><td>Buffer containing the key data</td></tr>
</tbody></table>
<h2><a class="header" href="#specific-response-status-codes-4" id="specific-response-status-codes-4">Specific response status codes</a></h2>
<ul>
<li><code>PsaErrorInvalidArgument</code>: The key is neither a public key nor a key pair.</li>
</ul>
<h2><a class="header" href="#description-4" id="description-4">Description</a></h2>
<p>The output of this function can be passed to <a href="parsec_client/operations/psa_import_key.html">PsaImportKey</a> to create an object
that is equivalent to the public key.</p>
<p>For standard key types, the output format is as follows:</p>
<ul>
<li>For RSA public keys, with key type <a href="parsec_client/operations/psa_key_attributes.html#rsapublickey-type"><code>RsaPublicKey</code></a>, the
DER encoding of the representation defined by <a href="https://tools.ietf.org/html/rfc3279.html#section-2.3.1">RFC 3279
§2.3.1</a> as <code>RSAPublicKey</code> (<code>[1]</code>).</li>
<li>For elliptic curve public keys, with key type
<a href="parsec_client/operations/psa_key_attributes.html#eccpublickey-type"><code>EccPublicKey</code></a>, the format depends on the <a href="parsec_client/operations/psa_key_attributes.html#supported-ecc-curve-families">curve
family</a>:
<ul>
<li>For Weierstrass curve families sectXX, secpXX, FRP and Brainpool, the uncompressed
representation defined by <em>Standards for Efficient Cryptography, SEC 1: Elliptic Curve
Cryptography</em> §2.3.3 as the content of an <code>ECPoint</code>. If <code>m</code> is the bit size associated with
the curve, i.e. the bit size of <code>q</code> for a curve over <code>F_q</code>. The representation consists of:</li>
<li>The byte <code>0x04</code>;</li>
<li><code>x_P</code> as a <code>ceiling(m/8)</code>-byte string, big-endian;</li>
<li><code>y_P</code> as a <code>ceiling(m/8)</code>-byte string, big-endian.</li>
<li>For Montgomery curve family, the scalar value of the ‘public key’ in little-endian order as
defined by <a href="https://tools.ietf.org/html/rfc7748.html#section-6">RFC 7748 §6</a>. This is a
<code>ceiling(m/8)</code>-byte string where <code>m</code> is the key size in bits.</li>
<li>This is 32 bytes for Curve25519, computed as <code>X25519(private_key, 9)</code>.</li>
<li>This is 56 bytes for Curve448, computed as <code>X448(private_key, 5)</code>.</li>
</ul>
</li>
<li>For Diffie-Hellman key exchange public keys, with key types
<a href="parsec_client/operations/psa_key_attributes.html#dhpublickey-type">DhPublicKey</a>, the format is the representation of the
public key <code>y = g^x mod p</code> as a big-endian byte string. The length of the byte string is the
length of the base prime <code>p</code> in bytes.</li>
</ul>
<p>Exporting a public key object or the public part of a key pair is always permitted, regardless of
the key’s usage flags.</p>
<p><code>[1]</code>: The <code>RSAPublicKey</code> representation is:</p>
<pre><code>RSAPublicKey ::= SEQUENCE {
    modulus INTEGER,       -- n
    publicExponent INTEGER -- e
}
</code></pre>
<h2><a class="header" href="#contract-4" id="contract-4">Contract</a></h2>
<p><a href="https://github.com/parallaxsecond/parsec-operations/blob/master/protobuf/psa_export_public_key.proto">Protobuf</a></p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#psaexportkey" id="psaexportkey">PsaExportKey</a></h1>
<p>Export a key in binary format. Opcode: 12 (<code>0x000C</code>)</p>
<h2><a class="header" href="#parameters-5" id="parameters-5">Parameters</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>key_name</code></td><td>String</td><td>Name of the key to export</td></tr>
</tbody></table>
<ul>
<li>The key must allow the <a href="parsec_client/operations/psa_key_attributes.html#usageflags-type">usage flag</a> <code>export</code>.</li>
</ul>
<h2><a class="header" href="#results-5" id="results-5">Results</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>data</code></td><td>Vector of bytes</td><td>Buffer containing the key data</td></tr>
</tbody></table>
<h2><a class="header" href="#specific-response-status-codes-5" id="specific-response-status-codes-5">Specific response status codes</a></h2>
<ul>
<li><code>PsaErrorNotPermitted</code>: The key is not have the [<code>export</code>] usage flag.</li>
</ul>
<h2><a class="header" href="#description-5" id="description-5">Description</a></h2>
<p>The output of this function can be passed to <a href="parsec_client/operations/psa_import_key.html">PsaImportKey</a> to create an object
that is equivalent to key.</p>
<p>For standard key types, the output format is as follows:</p>
<ul>
<li>For symmetric keys, including MAC keys, the format is the raw bytes of the key.</li>
<li>For <a href="parsec_client/operations/psa_key_attributes.html#des-type"><code>DES</code></a>, the key data consists of 8 bytes. The parity bits
must be correct.</li>
<li>For <a href="parsec_client/operations/psa_key_attributes.html#des-type"><code>Triple-DES</code></a>, the format is the concatenation of the two or
three DES keys.</li>
<li>For RSA key pairs, with key type <a href="parsec_client/operations/psa_key_attributes.html#rsakeypair-type"><code>RsaKeyPair</code></a>, the format
is the non-encrypted DER encoding of the representation defined by PKCS#1 in <a href="https://tools.ietf.org/html/rfc8017.html"><code>RFC 8017</code></a> as RSAPrivateKey, version 0 (<code>[1]</code>).</li>
<li>For elliptic curve key pairs, with key type <a href="parsec_client/operations/psa_key_attributes.html#ecckeypair-type"><code>EccKeyPair</code></a>,
the format is a representation of the private value.
<ul>
<li>For Weierstrass curve families <code>sectXX</code>, <code>secpXX</code>, <code>FRP</code> and <code>Brainpool</code>, the content of the
privateKey field of the ECPrivateKey format defined by <a href="https://tools.ietf.org/html/rfc5915.html"><code>RFC 5915</code></a>. This is a ceiling(m/8)-byte string in
big-endian order where m is the key size in bits.</li>
<li>For Montgomery curve family, the scalar value of the ‘private key’ in little-endian order
as defined by <a href="https://tools.ietf.org/html/rfc7748.html#section-6">RFC 7748 §6</a>. This is a
<code>ceiling(m/8)</code>-byte string where <code>m</code> is the key size in bits.
<ul>
<li>This is 32 bytes for Curve25519, computed as <code>X25519(private_key, 9)</code>.</li>
<li>This is 56 bytes for Curve448, computed as <code>X448(private_key, 5)</code>.</li>
</ul>
</li>
</ul>
</li>
<li>For Diffie-Hellman key exchange key pairs, with key types
<a href="parsec_client/operations/psa_key_attributes.html#dhkeypair-type">DhKeyPair</a>, the format is the representation of the
private key <code>x</code> as a big-endian byte string. The length of the byte string is the private key
size in bytes, and leading zeroes are not stripped.</li>
<li>For public keys, the format is the same as for <a href="parsec_client/operations/psa_export_public_key.html">PsaExportPublicKey</a></li>
</ul>
<p><code>[1]</code>: The <code>RSAPrivateKey</code> representation is:</p>
<pre><code>RSAPrivateKey ::= SEQUENCE {
             version           Version,
             modulus           INTEGER,  -- n
             publicExponent    INTEGER,  -- e
             privateExponent   INTEGER,  -- d
             prime1            INTEGER,  -- p
             prime2            INTEGER,  -- q
             exponent1         INTEGER,  -- d mod (p-1)
             exponent2         INTEGER,  -- d mod (q-1)
             coefficient       INTEGER,  -- (inverse of q) mod p
             otherPrimeInfos   OtherPrimeInfos OPTIONAL
         }
</code></pre>
<h2><a class="header" href="#contract-5" id="contract-5">Contract</a></h2>
<p><a href="https://github.com/parallaxsecond/parsec-operations/blob/master/protobuf/psa_export_key.proto">Protobuf</a></p>
<p><em>Copyright 2020 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#psageneratekey" id="psageneratekey">PsaGenerateKey</a></h1>
<p>Generate a key or key pair. Opcode: 2 (<code>0x0002</code>)</p>
<h2><a class="header" href="#parameters-6" id="parameters-6">Parameters</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>key_name</code></td><td>String</td><td>Name of the key to generate</td></tr>
<tr><td><code>attributes</code></td><td><a href="parsec_client/operations/psa_key_attributes.html#keyattributes-type"><code>KeyAttributes</code></a></td><td>The attributes of the new key</td></tr>
</tbody></table>
<h2><a class="header" href="#results-6" id="results-6">Results</a></h2>
<p>No values are returned by this operation.</p>
<h2><a class="header" href="#specific-response-status-codes-6" id="specific-response-status-codes-6">Specific response status codes</a></h2>
<ul>
<li><code>PsaErrorAlreadyExists</code>: There is already a key with the given name.</li>
</ul>
<h2><a class="header" href="#description-6" id="description-6">Description</a></h2>
<p>The key is generated randomly. Its location, policy, type and size are taken from <code>attributes</code>.</p>
<p>The following type-specific considerations apply:</p>
<ul>
<li>For RSA keys (key type is <a href="parsec_client/operations/psa_key_attributes.html#rsakeypair-type"><code>RsaKeyPair</code></a>), the public
exponent is 65537. The modulus is a product of two probabilistic primes between 2^{n-1} and 2^n
where n is the bit size specified in the attributes.</li>
</ul>
<h2><a class="header" href="#contract-6" id="contract-6">Contract</a></h2>
<p><a href="https://github.com/parallaxsecond/parsec-operations/blob/master/protobuf/psa_generate_key.proto">Protobuf</a></p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#psaimportkey" id="psaimportkey">PsaImportKey</a></h1>
<p>Import a key in binary format. Opcode: 6 (<code>0x0006</code>)</p>
<h2><a class="header" href="#parameters-7" id="parameters-7">Parameters</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>key_name</code></td><td>String</td><td>Name of the key to import</td></tr>
<tr><td><code>attributes</code></td><td><a href="parsec_client/operations/psa_key_attributes.html#keyattributes-type"><code>KeyAttributes</code></a></td><td>The attributes of the new key</td></tr>
<tr><td><code>data</code></td><td>Vector of bytes</td><td>Buffer containing the key data</td></tr>
</tbody></table>
<p>The content of the <code>data</code> buffer is interpreted according to the type declared in attributes. Parsec
supports the formats described in the documentation of PsaExportKey or
<a href="parsec_client/operations/psa_export_public_key.html">PsaExportPublicKey</a> for the chosen type. The key size is always
determined from the data buffer. If the key size in attributes is nonzero, it must be equal to the
size from data.</p>
<h2><a class="header" href="#results-7" id="results-7">Results</a></h2>
<p>No values are returned by this operation.</p>
<h2><a class="header" href="#specific-response-status-codes-7" id="specific-response-status-codes-7">Specific response status codes</a></h2>
<ul>
<li><code>PsaErrorAlreadyExists</code>: There is already a key with the given name.</li>
<li><code>PsaErrorNotSupported</code>: The key type or key size is not supported.</li>
<li><code>PsaErrorInvalidArgument</code>: The key attributes, as a whole, are invalid.</li>
<li><code>PsaErrorInvalidArgument</code>: The key data is not correctly formatted.</li>
<li><code>PsaErrorInvalidArgument</code>: The size in attributes is nonzero and does not match the size of the
key data.</li>
</ul>
<h2><a class="header" href="#description-7" id="description-7">Description</a></h2>
<p>This function supports any output from PsaExportKey. Refer to the documentation of
<a href="parsec_client/operations/psa_export_public_key.html">PsaExportPublicKey</a> for the format of public keys and to the
documentation of PsaExportKey for the format for other key types.</p>
<p>This specification supports a single format for each key type. Parsec might support other formats in
the future.</p>
<h2><a class="header" href="#contract-7" id="contract-7">Contract</a></h2>
<p><a href="https://github.com/parallaxsecond/parsec-operations/blob/master/protobuf/psa_import_key.proto">Protobuf</a></p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#psasignhash" id="psasignhash">PsaSignHash</a></h1>
<p>Sign an already-calculated hash with a private key. Opcode: 4 (<code>0x0004</code>)</p>
<h2><a class="header" href="#parameters-8" id="parameters-8">Parameters</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>key_name</code></td><td>String</td><td>Name of the key to use for the operation</td></tr>
<tr><td><code>alg</code></td><td><a href="parsec_client/operations/psa_algorithm.html#asymmetricsignature-algorithm"><code>AsymmetricSignature</code></a></td><td>An asymmetric signature algorithm that separates the hash and sign operations that is compatible with the type of key</td></tr>
<tr><td><code>hash</code></td><td>Vector of bytes</td><td>The input to sign</td></tr>
</tbody></table>
<ul>
<li><code>key_name</code> must be the name of an asymmetric key pair. The key must allow the <a href="parsec_client/operations/psa_key_attributes.html#usageflags-type">usage
flag</a> <code>sign_hash</code>.</li>
<li><code>hash</code> is usually the hash of a message. See the detailed description of this function and the
description of individual signature algorithms for a detailed description of acceptable inputs.</li>
</ul>
<h2><a class="header" href="#results-8" id="results-8">Results</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>signature</code></td><td>Vector of bytes</td><td>Buffer containing the signature</td></tr>
</tbody></table>
<h2><a class="header" href="#specific-response-status-codes-8" id="specific-response-status-codes-8">Specific response status codes</a></h2>
<ul>
<li><code>PsaErrorNotPermitted</code>: The key does not have the <code>sign_hash</code> flag, or it does not permit the
requested algorithm.</li>
</ul>
<h2><a class="header" href="#description-8" id="description-8">Description</a></h2>
<p>With most signature mechanisms that follow the hash-and-sign paradigm, the hash input to this
function is the hash of the message to sign. The hash algorithm is encoded in the signature
algorithm. Some hash-and-sign mechanisms apply a padding or encoding to the hash. In such cases, the
encoded hash must be passed to this function. The current version of this specification defines one
such signature algorithm: Raw PKCS#1 v1.5 signature.</p>
<p><strong>Note:</strong> To perform a hash-and-sign algorithm, the hash must be calculated before passing it to
this function. This could be done with the operation PsaHashCompute or with a multi-part hash
operation. Those operations are not yet implemented. Alternatively, to hash and sign a message in a
single call, you could use PsaSignMessage (not yet implemented).</p>
<h2><a class="header" href="#contract-8" id="contract-8">Contract</a></h2>
<p><a href="https://github.com/parallaxsecond/parsec-operations/blob/master/protobuf/psa_sign_hash.proto">Protobuf</a></p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#psa-key-attributes" id="psa-key-attributes">PSA Key Attributes</a></h1>
<p>The attributes are used to fully describe a cryptographic key: its type, size and what is permitted
to do with that key.</p>
<p>Some of the algorithms defined here are deprecated and should not be used without a valid reason. It
is at the discretion of the system administrator whether those algorithms are permitted or not.</p>
<p><strong>Notice:</strong> not all possible attributes are currently supported by Parsec. Please see the <a href="parsec_client/operations/../../service_api_coverage.html">API
coverage</a> for an overview of what Parsec currently supports. Some of
the attributes might not be supported by some providers as it is not in their interface.</p>
<h2><a class="header" href="#keyattributes-type" id="keyattributes-type">KeyAttributes type</a></h2>
<p>A <code>KeyAttributes</code> type contains the following members:</p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>key_type</code></td><td><a href="parsec_client/operations/psa_key_attributes.html#keytype-type"><code>KeyType</code></a></td><td>Intrinsic category and type of a key</td></tr>
<tr><td><code>key_bits</code></td><td>Unsigned integer</td><td>Size of a key in bits</td></tr>
<tr><td><code>key_policy</code></td><td><a href="parsec_client/operations/psa_key_attributes.html#keypolicy-type"><code>KeyPolicy</code></a></td><td>Policy restricting the permitted usage of the key</td></tr>
</tbody></table>
<h2><a class="header" href="#keytype-type" id="keytype-type">KeyType type</a></h2>
<p>A <code>KeyType</code> type can contain one of the following key types:</p>
<ul>
<li><a href="parsec_client/operations/psa_key_attributes.html#rawdata-type"><code>RawData</code></a></li>
<li><a href="parsec_client/operations/psa_key_attributes.html#hmac-type"><code>Hmac</code></a></li>
<li><a href="parsec_client/operations/psa_key_attributes.html#derive-type"><code>Derive</code></a></li>
<li><a href="parsec_client/operations/psa_key_attributes.html#aes-type"><code>Aes</code></a></li>
<li><a href="parsec_client/operations/psa_key_attributes.html#des-type"><code>Des</code></a></li>
<li><a href="parsec_client/operations/psa_key_attributes.html#camellia-type"><code>Camellia</code></a></li>
<li><a href="parsec_client/operations/psa_key_attributes.html#arc4-type"><code>Arc4</code></a></li>
<li><a href="parsec_client/operations/psa_key_attributes.html#chacha20-type"><code>Chacha20</code></a></li>
<li><a href="parsec_client/operations/psa_key_attributes.html#rsapublickey-type"><code>RsaPublicKey</code></a></li>
<li><a href="parsec_client/operations/psa_key_attributes.html#rsakeypair-type"><code>RsaKeyPair</code></a></li>
<li><a href="parsec_client/operations/psa_key_attributes.html#ecckeypair-type"><code>EccKeyPair</code></a></li>
<li><a href="parsec_client/operations/psa_key_attributes.html#eccpublickey-type"><code>EccPublicKey</code></a></li>
<li><a href="parsec_client/operations/psa_key_attributes.html#dhkeypair-type"><code>DhKeyPair</code></a></li>
<li><a href="parsec_client/operations/psa_key_attributes.html#dhpublickey-type"><code>DhPublicKey</code></a></li>
</ul>
<h3><a class="header" href="#rawdata-type" id="rawdata-type">RawData type</a></h3>
<p>Not a valid key type for any cryptographic operation but can be used to store arbitrary data in the
key store.</p>
<h3><a class="header" href="#hmac-type" id="hmac-type">Hmac type</a></h3>
<p>HMAC key. The key policy determines which underlying hash algorithm the key can be used for.</p>
<h3><a class="header" href="#derive-type" id="derive-type">Derive type</a></h3>
<p>A secret key for derivation. The key policy determines which key derivation algorithm the key can be
used for.</p>
<h3><a class="header" href="#aes-type" id="aes-type">Aes type</a></h3>
<p>Key for a cipher, AEAD or MAC algorithm based on the AES block cipher. The size of the key can be 16
bytes (AES-128), 24 bytes (AES-192) or 32 bytes (AES-256).</p>
<h3><a class="header" href="#des-type" id="des-type">Des type</a></h3>
<p>Key for a cipher or MAC algorithm based on DES or 3DES (Triple-DES). The size of the key can be 8
bytes (single DES), 16 bytes (2-key 3DES) or 24 bytes (3-key 3DES).</p>
<p><strong>Warning</strong>: Single DES and 2-key 3DES are weak and strongly deprecated and are only recommended for
decrypting legacy data. 3-key 3DES is weak and deprecated and is only recommended for use in legacy
protocols.</p>
<h3><a class="header" href="#camellia-type" id="camellia-type">Camellia type</a></h3>
<p>Key for a cipher, AEAD or MAC algorithm based on the Camellia block cipher.</p>
<h3><a class="header" href="#arc4-type" id="arc4-type">Arc4 type</a></h3>
<p>Key for the RC4 stream cipher. Use a <a href="parsec_client/operations/psa_algorithm.html#cipher-algorithm"><code>Cipher</code></a> algorithm with
Stream Cipher variant to use this key with the ARC4 cipher.</p>
<p><strong>Warning</strong>: The RC4 cipher is weak and deprecated and is only recommended for use in legacy
protocols.</p>
<h3><a class="header" href="#chacha20-type" id="chacha20-type">Chacha20 type</a></h3>
<p>Key for the ChaCha20 stream cipher or the Chacha20-Poly1305 AEAD algorithm. ChaCha20 and the
ChaCha20_Poly1305 construction are defined in <a href="https://tools.ietf.org/html/rfc7539.html">RFC 7539</a>.
Variants of these algorithms are defined by the length of the nonce:</p>
<ul>
<li>Implementations must support a 12-byte nonce, as defined in <a href="https://tools.ietf.org/html/rfc7539.html">RFC
7539</a>.</li>
<li>Implementations can optionally support an 8-byte nonce, the original variant.</li>
<li>It is recommended that implementations do not support other sizes of nonce.</li>
</ul>
<p>Use <a href="parsec_client/operations/psa_algorithm.html#cipher-algorithm"><code>Cipher</code></a> algorithm with Stream Cipher variant to use this
key with the ChaCha20 cipher for unauthenticated encryption.</p>
<h3><a class="header" href="#rsapublickey-type" id="rsapublickey-type">RsaPublicKey type</a></h3>
<p>RSA public key.</p>
<h3><a class="header" href="#rsakeypair-type" id="rsakeypair-type">RsaKeyPair type</a></h3>
<p>RSA key pair: both the private and public key.</p>
<h3><a class="header" href="#ecckeypair-type" id="ecckeypair-type">EccKeyPair type</a></h3>
<p>Elliptic curve key pair: both the private and public key. Uses one of the <a href="parsec_client/operations/psa_key_attributes.html#supported-ecc-curve-families">ECC curve family
supported</a>.</p>
<h3><a class="header" href="#eccpublickey-type" id="eccpublickey-type">EccPublicKey type</a></h3>
<p>Elliptic curve public key. Uses one of the <a href="parsec_client/operations/psa_key_attributes.html#supported-ecc-curve-families">ECC curve family
supported</a>.</p>
<h3><a class="header" href="#dhkeypair-type" id="dhkeypair-type">DhKeyPair type</a></h3>
<p>Diffie-Hellman key pair: both the private key and public key. Uses one of the <a href="parsec_client/operations/psa_key_attributes.html#supported-dh-group-families">Diffie-Hellman group
family supported</a>.</p>
<h3><a class="header" href="#dhpublickey-type" id="dhpublickey-type">DhPublicKey type</a></h3>
<p>Diffie-Hellman public key. Uses one of the <a href="parsec_client/operations/psa_key_attributes.html#supported-dh-group-families">Diffie-Hellman group family
supported</a>.</p>
<h3><a class="header" href="#supported-ecc-curve-families" id="supported-ecc-curve-families">Supported ECC curve families</a></h3>
<p>Enumeration of elliptic curve families supported. They are needed to create an ECC key. The specific
curve used for each family is given by the <code>key_bits</code> field of the key attributes.</p>
<ul>
<li><strong>SEC Koblitz curves over prime fields.</strong> This family comprises the following curves:
<ul>
<li>secp192k1: <code>key_bits</code> = 192</li>
<li>secp224k1: <code>key_bits</code> = 225</li>
<li>secp256k1: <code>key_bits</code> = 256</li>
</ul>
</li>
<li><strong>SEC random curves over prime fields.</strong> This family comprises the following curves:
<ul>
<li>secp192r1: <code>key_bits</code> = 192</li>
<li>secp224r1: <code>key_bits</code> = 224</li>
<li>secp256r1: <code>key_bits</code> = 256</li>
<li>secp384r1: <code>key_bits</code> = 384</li>
<li>secp521r1: <code>key_bits</code> = 512</li>
</ul>
</li>
<li><strong>SEC additional random curves over prime fields.</strong> This family comprises the following curves:
<ul>
<li>secp160r2: <code>key_bits</code> = 160 (DEPRECATED)</li>
</ul>
</li>
<li><strong>SEC Koblitz curves over binary fields.</strong> This family comprises the following curves:
<ul>
<li>sect163k1: <code>key_bits</code> = 163 (DEPRECATED)</li>
<li>sect233k1: <code>key_bits</code> = 233</li>
<li>sect239k1: <code>key_bits</code> = 239</li>
<li>sect283k1: <code>key_bits</code> = 283</li>
<li>sect409k1: <code>key_bits</code> = 409</li>
<li>sect571k1: <code>key_bits</code> = 571</li>
</ul>
</li>
<li><strong>SEC random curves over binary fields.</strong> This family comprises the following curves:
<ul>
<li>sect163r1: <code>key_bits</code> = 163 (DEPRECATED)</li>
<li>sect233r1: <code>key_bits</code> = 233</li>
<li>sect283r1: <code>key_bits</code> = 283</li>
<li>sect409r1: <code>key_bits</code> = 409</li>
<li>sect571r1: <code>key_bits</code> = 571</li>
</ul>
</li>
<li><strong>SEC additional random curves over binary fields.</strong> This family comprises the following curves:
<ul>
<li>sect163r2 : <code>key_bits</code> = 163 (DEPRECATED)</li>
</ul>
</li>
<li><strong>Brainpool P random curves.</strong> This family comprises the following curves:
<ul>
<li>brainpoolP160r1: <code>key_bits</code> = 160 (DEPRECATED)</li>
<li>brainpoolP192r1: <code>key_bits</code> = 192</li>
<li>brainpoolP224r1: <code>key_bits</code> = 224</li>
<li>brainpoolP256r1: <code>key_bits</code> = 256</li>
<li>brainpoolP320r1: <code>key_bits</code> = 320</li>
<li>brainpoolP384r1: <code>key_bits</code> = 384</li>
<li>brainpoolP512r1: <code>key_bits</code> = 512</li>
</ul>
</li>
<li><strong>FRP.</strong> Curve used primarily in France and elsewhere in Europe. This family comprises one 256-bit
curve:
<ul>
<li>FRP256v1: <code>key_bits</code> = 256</li>
</ul>
</li>
<li><strong>Montgomery curves.</strong> This family comprises the following Montgomery curves:
<ul>
<li>Curve25519: <code>key_bits</code> = 255</li>
<li>Curve448: <code>key_bits</code> = 448</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#supported-dh-group-families" id="supported-dh-group-families">Supported DH group families</a></h3>
<p>Enumeration of Diffie Hellman group families supported. They are needed to create a DH key. The
specific group used for each family is given by the <code>key_bits</code> field of the key attributes.</p>
<h2><a class="header" href="#keypolicy-type" id="keypolicy-type">KeyPolicy type</a></h2>
<p>Definition of the key policy, what is permitted to do with the key. A <code>KeyPolicy</code> type contains the
following members:</p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>key_usage_flags</code></td><td><a href="parsec_client/operations/psa_key_attributes.html#usageflags-type"><code>UsageFlags</code></a></td><td>Usage flags for the key</td></tr>
<tr><td><code>key_algorithm</code></td><td><a href="parsec_client/operations/psa_algorithm.html#algorithm-type"><code>Algorithm</code></a></td><td>Permitted algorithms to be used with the key</td></tr>
</tbody></table>
<h2><a class="header" href="#usageflags-type" id="usageflags-type">UsageFlags type</a></h2>
<p>Definition of the usage flags. They encode what kind of operations are permitted on the key. A
<code>UsageFlags</code> type contains the following members:</p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>export</code></td><td>Boolean</td><td>Permission to export the key</td></tr>
<tr><td><code>copy</code></td><td>Boolean</td><td>Permission to copy the key</td></tr>
<tr><td><code>cache</code></td><td>Boolean</td><td>Permission for the implementation to cache the key</td></tr>
<tr><td><code>encrypt</code></td><td>Boolean</td><td>Permission to encrypt a message with the key</td></tr>
<tr><td><code>decrypt</code></td><td>Boolean</td><td>Permission to decrypt a message with the key</td></tr>
<tr><td><code>sign_message</code></td><td>Boolean</td><td>Permission to sign a message with the key</td></tr>
<tr><td><code>verify_message</code></td><td>Boolean</td><td>Permission to verify a message with the key</td></tr>
<tr><td><code>sign_hash</code></td><td>Boolean</td><td>Permission to sign a hash with the key</td></tr>
<tr><td><code>verify_hash</code></td><td>Boolean</td><td>Permission to verify a hash with the key</td></tr>
<tr><td><code>derive</code></td><td>Boolean</td><td>Permission to derive other keys from this key</td></tr>
</tbody></table>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#psa-algorithm" id="psa-algorithm">PSA Algorithm</a></h1>
<p>The algorithm is used to select the specific cryptographic operation and to set a policy on a new
key.</p>
<p>Some of the algorithms defined here are deprecated and should not be used without a valid reason. It
is at the discretion of the system administrator whether those algorithms are permitted or not.</p>
<p><strong>Notice:</strong> not all possible algorithms are currently supported by Parsec. Please see the <a href="parsec_client/operations/../../service_api_coverage.html">API
coverage</a> for an overview of what Parsec currently supports. Some of
the attributes might not be supported by some providers as it is not in their interface.</p>
<h2><a class="header" href="#algorithm-type" id="algorithm-type">Algorithm type</a></h2>
<p>An <code>Algorithm</code> type can contain one of the following algorithm types:</p>
<ul>
<li><a href="parsec_client/operations/psa_algorithm.html#none-algorithm"><code>None</code></a></li>
<li><a href="parsec_client/operations/psa_algorithm.html#hash-algorithm"><code>Hash</code></a></li>
<li><a href="parsec_client/operations/psa_algorithm.html#mac-algorithm"><code>Mac</code></a></li>
<li><a href="parsec_client/operations/psa_algorithm.html#cipher-algorithm"><code>Cipher</code></a></li>
<li><a href="parsec_client/operations/psa_algorithm.html#aead-algorithm"><code>Aead</code></a></li>
<li><a href="parsec_client/operations/psa_algorithm.html#asymmetricsignature-algorithm"><code>AsymmetricSignature</code></a></li>
<li><a href="parsec_client/operations/psa_algorithm.html#asymmetricencryption-algorithm"><code>AsymmetricEncryption</code></a></li>
<li><a href="parsec_client/operations/psa_algorithm.html#keyagreement-algorithm"><code>KeyAgreement</code></a></li>
<li><a href="parsec_client/operations/psa_algorithm.html#keyderivation-algorithm"><code>KeyDerivation</code></a></li>
</ul>
<h3><a class="header" href="#none-algorithm" id="none-algorithm">None algorithm</a></h3>
<p>An invalid algorithm identifier value. None does not allow any cryptographic operation with the key.
The key can still be used for non-cryptographic actions such as exporting, if permitted by the usage
flags.</p>
<h3><a class="header" href="#hash-algorithm" id="hash-algorithm">Hash algorithm</a></h3>
<p>Possible hash algorithms are:</p>
<ul>
<li><strong>MD2.</strong> DEPRECATED: the MD2 hash is weak and deprecated and is only recommended for use in legacy
protocols.</li>
<li><strong>MD4.</strong> DEPRECATED: the MD4 hash is weak and deprecated and is only recommended for use in legacy
protocols.</li>
<li><strong>MD5.</strong> DEPRECATED: the MD5 hash is weak and deprecated and is only recommended for use in legacy
protocols.</li>
<li><strong>RIPEMD-160.</strong></li>
<li><strong>SHA-1.</strong></li>
<li><strong>SHA-224.</strong></li>
<li><strong>SHA-256.</strong></li>
<li><strong>SHA-384.</strong></li>
<li><strong>SHA-512.</strong></li>
<li><strong>SHA-512/224.</strong></li>
<li><strong>SHA-512/256.</strong></li>
<li><strong>SHA3-224.</strong></li>
<li><strong>SHA3-256.</strong></li>
<li><strong>SHA3-384.</strong></li>
<li><strong>SHA3-512.</strong></li>
</ul>
<h3><a class="header" href="#mac-algorithm" id="mac-algorithm">Mac algorithm</a></h3>
<p>The Message Authentication Code algorithms supported are:</p>
<ul>
<li><strong>HMAC.</strong> Uses one of the hash algorithm supported.</li>
<li><strong>CBC-MAC</strong> construction over a block cipher. <strong>Warning:</strong> CBC-MAC is insecure in many cases. A
more secure mode, such as CMAC, is recommended.</li>
<li><strong>CMAC</strong> construction over a block cipher.</li>
</ul>
<p>Truncated MAC algorithms are also supported. A truncated MAC algorithm is identical to the
corresponding MAC algorithm except that the MAC value for the truncated algorithm consists of only
the first wanted bytes of the MAC value for the untruncated algorithm.</p>
<h3><a class="header" href="#cipher-algorithm" id="cipher-algorithm">Cipher algorithm</a></h3>
<p>Unauthenticated cipher alhorithms.</p>
<p><strong>Warning:</strong> The unauthenticated cipher API is provided to implement legacy protocols and for use
cases where the data integrity and authenticity is guaranteed by non-cryptographic means. It is
recommended that newer protocols use Authenticated Encryption with Associated Data (AEAD).</p>
<ul>
<li><strong>Stream Cipher</strong>: the stream cipher mode of a stream cipher algorithm. The underlying stream
cipher is determined by the key type:
<ul>
<li>To use ChaCha20, use the <a href="parsec_client/operations/psa_key_attributes.html#chacha20-type"><code>Chacha20</code></a> key type.</li>
<li>To use ARC4, use the <a href="parsec_client/operations/psa_key_attributes.html#arc4-type"><code>Arc4</code></a> key type.</li>
</ul>
</li>
<li><strong>CTR</strong>: A stream cipher built using the Counter (CTR) mode of a block cipher. CTR is a stream
cipher which is built from a block cipher. The underlying block cipher is determined by the key
type. For example, to use AES-128-CTR, use this algorithm with a key of type AES and a length of
128 bits (16 bytes).</li>
<li><strong>CFB</strong>: A stream cipher built using the Cipher Feedback (CFB) mode of a block cipher. The
underlying block cipher is determined by the key type.</li>
<li><strong>OFB</strong>: A stream cipher built using the Output Feedback (OFB) mode of a block cipher. The
underlying block cipher is determined by the key type.</li>
<li><strong>XTS</strong>: The XTS cipher mode of a block cipher. XTS is a cipher mode which is built from a block
cipher. It requires at least one full block of input, but beyond this minimum the input does not
need to be a whole number of blocks.</li>
<li><strong>ECB with no padding</strong>: The Electronic Code Book (ECB) mode of a block cipher, with no padding.
The underlying block cipher is determined by the key type. <strong>Warning:</strong> ECB mode does not protect
the confidentiality of the encrypted data except in extremely narrow circumstances. It is
recommended that applications only use ECB if they need to construct an operating mode that the
implementation does not provide. Implementations are encouraged to provide the modes that
applications need in preference to supporting direct access to ECB.</li>
<li><strong>CBC with no padding</strong>: The Cipher Block Chaining (CBC) mode of a block cipher, with no padding.
The underlying block cipher is determined by the key type.</li>
<li><strong>CBC with PKCS#7 padding</strong>: The Cipher Block Chaining (CBC) mode of a block cipher, with PKCS#7
padding. The underlying block cipher is determined by the key type.</li>
</ul>
<h3><a class="header" href="#aead-algorithm" id="aead-algorithm">Aead algorithm</a></h3>
<p>Authenticated encryption with associated data (AEAD). The supported algorithms are:</p>
<ul>
<li><strong>CCM</strong>: the CCM authenticated encryption algorithm. The underlying block cipher is determined by
the key type.</li>
<li><strong>GCM</strong>: the GCM authenticated encryption algorithm. The underlying block cipher is determined by
the key type.</li>
<li><strong>ChaCha20-Poly1305</strong>: the ChaCha20-Poly1305 AEAD algorithm. The ChaCha20-Poly1305 construction is
defined in <a href="https://tools.ietf.org/html/rfc7539.html">RFC 7539</a>.</li>
</ul>
<p>AEAD algorithms with a shortened tag are also supported. An AEAD algorithm with a shortened tag is
similar to the corresponding AEAD algorithm, but has an authentication tag that consists of fewer
bytes. Depending on the algorithm, the tag length might affect the calculation of the ciphertext.</p>
<h3><a class="header" href="#asymmetricsignature-algorithm" id="asymmetricsignature-algorithm">AsymmetricSignature algorithm</a></h3>
<p>Asymmetric signature algorithms. Supported algorithms:</p>
<ul>
<li><strong>RSA PKCS#1 v1.5 signature with hashing.</strong> This is the signature scheme defined by <a href="https://tools.ietf.org/html/rfc8017.html">RFC
8017</a> (PKCS#1: RSA Cryptography Specifications) under
the name RSASSA-PKCS1-v1_5. Uses one of the hash algorithm supported.</li>
<li><strong>Raw PKCS#1 v1.5 signature.</strong> The input to this algorithm is the DigestInfo structure used by
<a href="https://tools.ietf.org/html/rfc8017.html">RFC 8017</a> §9.2 (PKCS#1: RSA Cryptography
Specifications), in steps 3–6.</li>
<li><strong>RSA PSS signature with hashing.</strong> This is the signature scheme defined by <a href="https://tools.ietf.org/html/rfc8017.html">RFC
8017</a> (PKCS#1: RSA Cryptography Specifications) under
the name RSASSA-PSS, with the message generation function MGF1, and with a salt length equal to
the length of the hash. The specified hash algorithm is used to hash the input message, to create
the salted hash, and for the mask generation. Uses one of the hash algorithm supported.</li>
<li><strong>ECDSA signature with hashing.</strong> This is the Elliptic Curve Digital Signature Algorithm (ECDSA)
defined by ANSI X9.62-2005, with a random per-message secret number (k). The representation of
the signature as a byte string consists of the concatenation of the signature values r and s.
Each of r and s is encoded as an N-octet string, where N is the length of the base point of the
curve in octets. Each value is represented in big-endian order, with the most significant octet
first. Uses one of the hash algorithm supported.</li>
<li><strong>ECDSA signature without hashing.</strong> This is the same signature scheme as above, but without
specifying a hash algorithm. This algorithm is only recommended to sign or verify a sequence of
bytes that are an already-calculated hash. Note that the input is padded with zeros on the left
or truncated on the left as required to fit the curve size.</li>
<li><strong>Deterministic ECDSA signature with hashing.</strong> This is the deterministic ECDSA signature scheme
defined by <a href="https://tools.ietf.org/html/rfc6979.html">RFC 6979</a>. Uses one of the hash algorithm
supported.</li>
</ul>
<p>When defining the permitted algorithms in a key policy, the hash-and-sign algorithms above can use
the value <strong>Any Hash</strong> for their hash algorithm, meaning that it will allow any hash algorithm. This
value must not be used to build an algorithm specification to perform an operation. It is only valid
to build policies.</p>
<h3><a class="header" href="#asymmetricencryption-algorithm" id="asymmetricencryption-algorithm">AsymmetricEncryption algorithm</a></h3>
<p>Asymmetric encryption algorithms. Supported algorithms:</p>
<ul>
<li><strong>RSA PKCS#1 v1.5 encryption.</strong></li>
<li><strong>RSA OAEP encryption.</strong> This is the encryption scheme defined by <a href="https://tools.ietf.org/html/rfc6979.html">RFC
8017</a> (PKCS#1: RSA Cryptography Specifications) under
the name RSAES-OAEP, with the message generation function MGF1. Uses one of the supported hash
algorithms.</li>
</ul>
<h3><a class="header" href="#keyagreement-algorithm" id="keyagreement-algorithm">KeyAgreement algorithm</a></h3>
<p>Key agreement algorithms.</p>
<ul>
<li><strong>FFDH</strong>: the finite-field Diffie-Hellman (DH) key agreement algorithm.</li>
<li><strong>ECDH</strong>: the elliptic curve Diffie-Hellman (ECDH) key agreement algorithm.</li>
</ul>
<p>A combined algorithm that chains a key agreement with a key derivation is also supported.</p>
<h3><a class="header" href="#keyderivation-algorithm" id="keyderivation-algorithm">KeyDerivation algorithm</a></h3>
<p>Key derivation algorithms.</p>
<ul>
<li><strong>HKDF algorithm.</strong> Uses of the hash algorithms supported.</li>
<li><strong>TLS-1.2 PRF algorithm.</strong> Uses of the hash algorithms supported.</li>
<li><strong>TLS-1.2 PSK-to-MasterSecret algorithm.</strong> Uses of the hash algorithms supported.</li>
</ul>
<p><em>Copyright 2020 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#psaverifyhash" id="psaverifyhash">PsaVerifyHash</a></h1>
<p>Verify the signature of a hash or short message using a public key. Opcode: 5 (<code>0x0005</code>)</p>
<h2><a class="header" href="#parameters-9" id="parameters-9">Parameters</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>key_name</code></td><td>String</td><td>Name of the key to use for the operation</td></tr>
<tr><td><code>alg</code></td><td><a href="parsec_client/operations/psa_algorithm.html#asymmetricsignature-algorithm"><code>AsymmetricSignature</code></a></td><td>An asymmetric signature algorithm that separates the hash and sign operations that is compatible with the type of key</td></tr>
<tr><td><code>hash</code></td><td>Vector of bytes</td><td>The input whose signature is to be verified</td></tr>
<tr><td><code>signature</code></td><td>Vector of bytes</td><td>Buffer containing the signature to verify</td></tr>
</tbody></table>
<ul>
<li><code>key_name</code> must be the name of a public key or an asymmetric key pair. The key must allow the
<a href="parsec_client/operations/psa_key_attributes.html#usageflags-type">usage flag</a> <code>verify_hash</code>.</li>
<li><code>hash</code> is usually the hash of a message. See the detailed description of this function and the
description of individual signature algorithms for a detailed description of acceptable inputs.</li>
</ul>
<h2><a class="header" href="#results-9" id="results-9">Results</a></h2>
<p>No values are returned by this operation. If <code>Sucess</code> is returned the signature is valid.</p>
<h2><a class="header" href="#specific-response-status-codes-9" id="specific-response-status-codes-9">Specific response status codes</a></h2>
<ul>
<li><code>PsaErrorNotPermitted</code>: The key does not have the <code>verify_hash</code> flag, or it does not permit the
requested algorithm.</li>
<li><code>PsaErrorInvalidSignature</code>: The calculation was performed successfully, but the passed signature
is not a valid signature.</li>
</ul>
<h2><a class="header" href="#description-9" id="description-9">Description</a></h2>
<p>With most signature mechanisms that follow the hash-and-sign paradigm, the hash input to this
function is the hash of the message to sign. The hash algorithm is encoded in the signature
algorithm. Some hash-and-sign mechanisms apply a padding or encoding to the hash. In such cases, the
encoded hash must be passed to this function. The current version of this specification defines one
such signature algorithm: Raw PKCS#1 v1.5 signature.</p>
<p><strong>Note:</strong> To perform a hash-and-sign algorithm, the hash must be calculated before passing it to
this function. This could be done with the operation PsaHashCompute or with a multi-part hash
operation. Those operations are not yet implemented. Alternatively, to hash and verify a message
signature in a single call, you could use PsaVerifyMessage (not yet implemented).</p>
<h2><a class="header" href="#contract-9" id="contract-9">Contract</a></h2>
<p><a href="https://github.com/parallaxsecond/parsec-operations/blob/master/protobuf/psa_verify_hash.proto">Protobuf</a></p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#psaasymmetricencrypt" id="psaasymmetricencrypt">PsaAsymmetricEncrypt</a></h1>
<p>Encrypt a short message with a public key. Opcode: 10 (<code>0x000A</code>)</p>
<h2><a class="header" href="#parameters-10" id="parameters-10">Parameters</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>key_name</code></td><td>String</td><td>Name of the key to use for the operation</td></tr>
<tr><td><code>alg</code></td><td><a href="parsec_client/operations/psa_algorithm.html#asymmetricencryption-algorithm"><code>AsymmetricEncryption</code></a></td><td>An asymmetric encryption algorithm that is compatible with the type of key</td></tr>
<tr><td><code>plaintext</code></td><td>Vector of bytes</td><td>Short message to encrypt</td></tr>
<tr><td><code>salt</code></td><td>Vector of bytes</td><td>Salt to use during encryption, if supported by the algorithm</td></tr>
</tbody></table>
<ul>
<li><code>key_name</code> must be the name of an RSA asymmetric key pair or public key. The key must allow the
<a href="parsec_client/operations/psa_key_attributes.html#usageflags-type">usage flag</a> <code>encrypt</code>.</li>
<li><code>salt</code> can be provided if supported by the algorithm. If the algorithm does not support salt, pass
an empty vector. If the algorithm supports optional salt, pass an empty vector to indicate no
salt. For RSA PKCS#1 v1.5 encryption, no salt is supported.</li>
</ul>
<h2><a class="header" href="#results-10" id="results-10">Results</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ciphertext</code></td><td>Vector of bytes</td><td>Buffer containing the encrypted message</td></tr>
</tbody></table>
<h2><a class="header" href="#specific-response-status-codes-10" id="specific-response-status-codes-10">Specific response status codes</a></h2>
<ul>
<li><code>PsaErrorNotPermitted</code>: The key does not have the <code>encrypt</code> flag, or it does not permit the
requested algorithm.</li>
</ul>
<h2><a class="header" href="#description-10" id="description-10">Description</a></h2>
<p>This function will encrypt a short message with the public key provided, or of the provided key
pair.</p>
<h2><a class="header" href="#contract-10" id="contract-10">Contract</a></h2>
<p><a href="https://github.com/parallaxsecond/parsec-operations/blob/master/protobuf/psa_asymmetric_encrypt.proto">Protobuf</a></p>
<p><em>Copyright 2020 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#psaasymmetricdecrypt" id="psaasymmetricdecrypt">PsaAsymmetricDecrypt</a></h1>
<p>Decrypt a short message with a private key. Opcode: 11 (<code>0x000B</code>)</p>
<h2><a class="header" href="#parameters-11" id="parameters-11">Parameters</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>key_name</code></td><td>String</td><td>Name of the key to use for the operation</td></tr>
<tr><td><code>alg</code></td><td><a href="parsec_client/operations/psa_algorithm.html#asymmetricencryption-algorithm"><code>AsymmetricEncryption</code></a></td><td>An asymmetric encryption algorithm that is compatible with the type of key</td></tr>
<tr><td><code>ciphertext</code></td><td>Vector of bytes</td><td>Short message to decrypt</td></tr>
<tr><td><code>salt</code></td><td>Vector of bytes</td><td>Salt to use during encryption, if supported by the algorithm</td></tr>
</tbody></table>
<ul>
<li><code>key_name</code> must be the name of an RSA asymmetric key pair. The key must allow the <a href="parsec_client/operations/psa_key_attributes.html#usageflags-type">usage
flag</a> <code>decrypt</code>.</li>
<li><code>salt</code> can be provided if supported by the algorithm. If the algorithm does not support salt, pass
an empty vector. If the algorithm supports optional salt, pass an empty vector to indicate no
salt. For RSA PKCS#1 v1.5 encryption, no salt is supported.</li>
</ul>
<h2><a class="header" href="#results-11" id="results-11">Results</a></h2>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>plaintext</code></td><td>Vector of bytes</td><td>Buffer containing the decrypted message</td></tr>
</tbody></table>
<h2><a class="header" href="#specific-response-status-codes-11" id="specific-response-status-codes-11">Specific response status codes</a></h2>
<ul>
<li><code>PsaErrorNotPermitted</code>: The key does not have the <code>decrypt</code> flag, or it does not permit the
requested algorithm.</li>
</ul>
<h2><a class="header" href="#description-11" id="description-11">Description</a></h2>
<p>This function will decrypt a short message with the private key of the provided key pair.</p>
<h2><a class="header" href="#contract-11" id="contract-11">Contract</a></h2>
<p><a href="https://github.com/parallaxsecond/parsec-operations/blob/master/protobuf/psa_asymmetric_decrypt.proto">Protobuf</a></p>
<p><em>Copyright 2020 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#sharetrustbundle" id="sharetrustbundle">ShareTrustBundle</a></h1>
<p>Placeholder page.</p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#api-overview" id="api-overview">API Overview</a></h1>
<h2><a class="header" href="#introduction-1" id="introduction-1">Introduction</a></h2>
<p>This document introduces the API contract that exists between the client and the service, covering
its general principles and organisation. Use this document in combination with the <a href="parsec_client/wire_protocol.html"><strong>wire protocol
specification</strong></a> and the <a href="parsec_client/operations"><strong>operation directory</strong></a> as a reference
guide for the development of client libraries.</p>
<h2><a class="header" href="#status-note-1" id="status-note-1">Status Note</a></h2>
<p>This is preliminary documentation. It may be incomplete, and is subject to change without notice.</p>
<h2><a class="header" href="#audience" id="audience">Audience</a></h2>
<p>This document details the API that is exposed directly by the service to its clients. This is the
API that is invoked over the IPC transport between the client process and the service. Client
applications do not consume this API directly. Instead, they consume a client library in their
chosen programming language. The client library will present an idiomatic and simplified view of the
API, making heavy use of argument defaulting to shield application developers from much of the
complexity of invoking cryptographic operations. Client libraries should present the API in a form
that is &quot;easy to use and hard to get wrong&quot;. The audience for this document is the client library
developer, <em>not</em> the application developer. Application developers should consult the client library
documentation package instead.</p>
<h2><a class="header" href="#opcodes-and-contracts" id="opcodes-and-contracts">Opcodes and Contracts</a></h2>
<p>The API is expressed as a set of individual and distinct <strong>operations</strong>. Each operation has a unique
numerical <strong>opcode</strong> to set it apart from other operations, and to allow for it to be unambiguously
selected for in a client request. (See the <a href="parsec_client/wire_protocol.html"><strong>wire protocol specification</strong></a> for
information about how the client must structure such requests). Each operation also has an <strong>input
contract</strong>, which defines the arguments that the client must supply when invoking it. It also has an
<strong>output contract</strong>, which defines the operation results that the client can expect to receive from
the service upon completion. In current manifestations of the API, all input and output contracts
are defined as protobuf messages, which provides a strong contractual definition and good
interoperability with multiple programming languages.</p>
<p>All operations are catalogued in the <a href="parsec_client/operations"><strong>operation directory</strong></a>. There is a separate
documentation page for each operation, which will specify the correct opcode to use, and will
provide links to the input and output contracts.</p>
<p>In order to make an API call, the client must use the <a href="parsec_client/wire_protocol.html"><strong>wire protocol
specification</strong></a> to form a valid request to the service. The request header must
contain the opcode of the operation being performed, and the request body must contain serialized
data bytes conforming to that operation's input contract. The service will execute the operation,
and form a response according to the wire protocol. The response will contain serialized data bytes
conforming to the operation's output contract.</p>
<h2><a class="header" href="#selecting-providers" id="selecting-providers">Selecting Providers</a></h2>
<p>All of the operations in the API are implemented by back-end modules known as <strong>providers</strong>. A
provider is a module that is capable of implementing operations by making use of available platform
hardware or services. For example, if cryptographic services are supplied by a hardware secure
element of some kind, then there would be a provider for that secure element. There may be a
different provider for a software-only solution. And so forth. It is valid for these different
providers to co-reside within the service. The availability of providers is governed by
configuration that is applied at service-deployment time.</p>
<p>While the service can be composed from multiple providers, any given API operation needs to be
implemented by a single provider. This means that client code needs to specify the target provider
when it makes an operation request. To achieve this, the service assigns an 8-bit integer value
(from 0 to 255) to each available provider. In practice, the numer of providers would be very small:
probably just two or three. This integer value is the <strong>provider identifier</strong>. Client code must set
a single provider identifier in each API request. The <a href="parsec_client/wire_protocol.html"><strong>wire protocol
specification</strong></a> explains how a request header field is used to route the request
to the correct provider.</p>
<p>In order to set a provider identifier in an API request, the client must first be able to determine
what providers are available, what their identifiers are, and what their characteristics are (such
as whether they are hardware-backed or software-backed). This is done by first referencing the
<strong>core provider</strong>. The core provider is the only provider that is guaranteed to be available in any
deployment of the service. It has a provider identifier of zero (the only reserved value for
provider identifiers). The core provider is special in that it doesn't implement any security or
cryptographic operations. The core provider is used to represent the service as a whole. The
operations of the core provider can be used to gather information about the health and configuration
of the service. It can be used to ping the service to check whether it is responsive, and to check
the highest version of the wire protocol that it supports. The core provider can also be used to get
information about the cryptographic providers, their characteristics and their 8-bit identifier
values. Based on this information, the client can determine which provider is best suited to its
requirements. It can then use the integer identifier of that provider to make API requests.</p>
<p>The expected pattern is that a client would determine a single provider that best suits its needs,
and then use that provider exclusively for all cryptographic operations. While this usage would be
considered typical, it is certainly not enforced. There is nothing to prevent a client from using
different providers for different operations if it so desires. In many deployments, it is possible
that only a single cryptographic provider would be available anyway. To determine the best available
or most suitable provider, a client application can use the capability check mechanism, described
below.</p>
<h2><a class="header" href="#open-closed-principle" id="open-closed-principle">Open-Closed Principle</a></h2>
<p>The API is designed to evolve over time. This evolution will be governed by the <em>open-closed
principle</em>. In practice, this means that each operation in the API, once introduced, will not be
contractually modified. The API can only change by introducing new operations. This preserves
backwards compatability with client code. Any client code that makes use of any given operation will
continue to work, even if new operations are introduced.</p>
<h2><a class="header" href="#deprecation" id="deprecation">Deprecation</a></h2>
<p>While the open-closed principle dictates that operations will not be contractually changed once they
have been introduced, it may sometimes be necessary to deprecate specific operations. This will
often be to encourage the use of a new operation with an improved feature set and a different
contract. Deprecation is largely a documentation exercise: the <a href="parsec_client/operations"><strong>operation directory</strong></a>
will indicate when an operation has been deprecated. This does not mean that the operation will no
longer work. It simply means that any new use of the operation is strongly discouraged in favour of
a better alternative.</p>
<h2><a class="header" href="#capability-checks" id="capability-checks">Capability Checks</a></h2>
<p>The API includes a capability check operation, which allows the client to determine the set of
operations that are available. There are two reasons why the client needs this capability check:</p>
<ul>
<li>The API can evolve over time, introducing new operations with new opcodes. In general, a client
cannot know whether it is talking to a service that supports these newer operations, so it needs
to check the level of support in advance.</li>
<li>Different cryptographic providers have different capabilities. An operation that is supported in
one provider might not be supported in another.</li>
</ul>
<p>Refer to the <a href="parsec_client/operations"><strong>operation directory</strong></a> for information on how to perform a capability
check.</p>
<h2><a class="header" href="#application-identity" id="application-identity">Application Identity</a></h2>
<p>Every client application that uses the API must present an <strong>application identity</strong>. Application
identities are arbitrary byte strings, which are used by the service to isolate the activities of
one client from those of another. The storage of secure assets such as keys is segregated on a
per-client basis: assets created by one client cannot be accessed by another. The service always
uses the client's application identity string to maintain this separation.</p>
<p>The means by which application identities are generated or assigned is outside of the scope of this
specification. The only requirements for application identities is that they must be <strong>unique</strong> and
<strong>stable</strong>. This means that any given application identity string can be used to identify one and
only one client application. It also means that the application identity string for any given client
should remain the same over time, even across system resets.</p>
<p>The granularity of application identities is not defined. In particular, there is no assumption that
a client <em>application</em> corresponds precisely with a single client <em>process</em>. A client application
might be composed of multiple processes. Conversely, a single process might contain multiple
distinct client applications. Client applications might also be organised into isolated environments
such as containers. Provided that client application is able to present a unique and stable identity
string for each API call, it does not matter how they are structured and deployed.</p>
<h2><a class="header" href="#authentication-and-sessions" id="authentication-and-sessions">Authentication and Sessions</a></h2>
<p>Clients present their identity strings to the service on each API call. As set out in the <a href="parsec_client/wire_protocol.html"><strong>wire
protocol specification</strong></a>, they do this using the <strong>authentication</strong> field of the
API request.</p>
<p>There are two ways in which the client can use the authentication field to share its identity with
the service: <strong>direct authentication</strong> and <strong>authentication tokens</strong>.</p>
<p>With <strong>direct authentication</strong>, the client authenticates the request by directly copying the
application identity string into the <strong>authentication</strong> field of the request.</p>
<p>With <strong>authentication tokens</strong>, the client obtains a token from an identity provider and sends it as
the <strong>authentication</strong> field of the request. The token is reusable for a specified duration of time,
after which a new one must be issued. The application identity is contained in the token and can be
extracted by the service after verifying the authenticity of the token. A more detailed description
of authentication tokens and their lifecycle is present in the <a href="parsec_client/../parsec_service/system_architecture.html"><strong>sytem architecture
specification</strong></a>.</p>
<p>When it makes an API request, the client needs to tell the server which kind of authentication is
being used. This is so that the server knows how to interepret the bytes in the <strong>authentication</strong>
field of the request. As described in the <a href="parsec_client/wire_protocol.html"><strong>wire protocol specification</strong></a>, the
client does this by setting an integer value in the <strong>auth type</strong> field of the request header. The
permitted numerical values for this field are given as follows:-</p>
<ul>
<li>A value of 0 (<code>0x00</code>) indicates that there is no authentication. The service will not expect any
content in the <strong>authentication</strong> field of the request. If any authentication bytes are present,
they will be ignored, but the request will still be considered valid. (For clients, it is
considered bad practice to supply a non-empty <strong>authentication</strong> field in this case, because it
is contradictory to supply authentication material while indicating an unauthenticated call, and
it indicates improper coding or a possible defect on the client side). See the section below on
unauthenticated operations.</li>
<li>A value of 1 (<code>0x01</code>) indicates direct authentication. The service will expect the
<strong>authentication</strong> field to contain a cleartext copy of the application identity.</li>
<li>A value of 2 (<code>0x02</code>) indicates authentication tokens. The service will expect the
<strong>authentication</strong> field to contain a JWT token. Tokens must be signed with the private key of
the identity provider and their validity period must cover the moment when the check is done.</li>
</ul>
<p>Other values are unsupported and will be rejected by the service.</p>
<h2><a class="header" href="#unauthenticated-operations" id="unauthenticated-operations">Unauthenticated Operations</a></h2>
<p>Authentication via the application identity is only needed for cryptographic operations. Core
provider operations do not require authentication. Core provider operations include those that are
used to ping the service and gather information about its capabilities. These operations neither
require nor support any notion of per-client isolation. Consequently, they can be called without any
authentication. For requests to the core provider, the <strong>auth type</strong> header field should always be
set to 0 (<code>0x00</code>).</p>
<h2><a class="header" href="#content-type-and-accept-type" id="content-type-and-accept-type">Content Type and Accept Type</a></h2>
<p>As per the <a href="parsec_client/wire_protocol.html"><strong>wire protocol specification</strong></a>, API request headers contain fields
for <strong>content type</strong> and <strong>accept type</strong>, which respectively indicate how the request body and
response body are encoded. Currently, the only supported value for these fields is 1 (<code>0x01</code>),
meaning that all request and response bodies contain serialized protobuf messages. All other values
are unsupported and will be rejected by the service.</p>
<h2><a class="header" href="#psa-crypto-operations-1" id="psa-crypto-operations-1">PSA Crypto Operations</a></h2>
<p>The majority of the operations in this API are derived from the <a href="https://github.com/ARMmbed/mbed-crypto/blob/psa-crypto-api/docs/PSA_Cryptography_API_Specification.pdf"><strong>PSA Crypto API
Specification</strong></a>.
There is a near one-to-one correspondence of functional operations between the two APIs. The main
difference is that the PSA Crypto API is defined in the C programming language, whereas the API
described here is language-agnostic. There is otherwise a close contractual equivalence between the
two, and this is intentional.</p>
<p>In the <a href="parsec_client/operations"><strong>operation directory</strong></a>, operations derived from the PSA Crypto API have
symbolic names that start with the <strong>Psa</strong> prefix, and their numerical opcodes are all in the
1,000-1,999 (decimal) range. Opcode ranges are an important aspect of the API design because they
form the basis of an extensibility mechanism. In the future, it will be possible for contributors to
partition the numerical opcode space with ranges for custom operations.</p>
<h2><a class="header" href="#key-names-enumerating-and-referencing" id="key-names-enumerating-and-referencing">Key Names, Enumerating and Referencing</a></h2>
<p>While this API is closely aligned with the PSA Crypto API, there are some differences. One important
difference is in the conventions used to name and reference cryptographic keys.</p>
<p>In the PSA Crypto API, every key has a 32-bit numerical identifier. This identifier is set by the
caller when the key is created. Client code then uses this 32-bit identifier to <strong>open</strong> the key. A
key must be opened before it can be used in any cryptographic operations. An open key is referenced
using a <strong>handle</strong> (which is distinct from the identifier). The handle is the only way that the
client code can involve the key in cryptographic functions. Once the client has finished using the
key, it <strong>closes</strong> the handle.</p>
<p>This API differs in two ways. Firstly, the key names are not 32-bit numerical values: they are
<strong>strings</strong>. Secondly, there is no notion of key handles. Keys are always referenced by name. There
is no operation to open or close a key. Cryptographic operations are all specified in terms of the
key name string. However, while the notion of a key handle is absent, it is important to understand
that the opacity of keys - one of the critical design characteristics of the PSA Crypto API - is
preserved here. Key names are used to reference keys for cryptographic operations, but the actual
key material is <em>never</em> exposed to the caller of the API unless an explicit operation is invoked to
export the key (and the key's usage policy permits for such an export to occur).</p>
<p>The use of string names offers greater flexibility in how names can be chosen and structured. It
allows for names to be readable and meaningful. It also allows for names to follow a structured
pattern with separators, similar to a file path. This allows keys to not only be named in meaningful
ways, but also for them to be organised according to a meaningful structure, just like files on a
file system. Keys with a similar purpose, for example, can be stored in the same part of the
notional &quot;tree&quot;.</p>
<p>Key names adopt a path structure similar to Unix file paths, such as <code>/keys/rsa/my_key_1</code>.</p>
<p>This key naming convention permits for the API to support key <strong>enumeration</strong>, where the client is
able to determine the set of known keys according to some wildcard pattern such as <code>/keys/rsa/*</code>.</p>
<p>All key names are implicitly in a per-client namespace, so it is impossible for one client
application to enumerate or otherwise discover the keys that are owned by another client
application.</p>
<p>Providers can impose length restrictions on key names to help with internal storage and argument
validation. This API reference does not define any single fixed maximum length. Clients must
determine the maximum length at runtime using the capability checking mechanism.</p>
<h2><a class="header" href="#full-api-reference" id="full-api-reference">Full API Reference</a></h2>
<p>For the full reference guide to individual API operations, please refer to the <a href="parsec_client/operations"><strong>operation
directory</strong></a>.</p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#response-status-codes" id="response-status-codes">Response Status Codes</a></h1>
<p>The value 0, <code>Success</code>, is for a successful operation.</p>
<h2><a class="header" href="#service-internal-response-status-codes" id="service-internal-response-status-codes">Service Internal Response Status Codes</a></h2>
<p>These codes originate in components in the service outside of the <code>Provide</code> trait implementation by
the providers.</p>
<table><thead><tr><th>Response Status Code</th><th>Value</th><th>Descrption</th></tr></thead><tbody>
<tr><td><code>WrongProviderID</code></td><td>1</td><td>Requested provider ID does not match that of the backend</td></tr>
<tr><td><code>ContentTypeNotSupported</code></td><td>2</td><td>Requested content type is not supported by the backend</td></tr>
<tr><td><code>AcceptTypeNotSupported</code></td><td>3</td><td>Requested accept type is not supported by the backend</td></tr>
<tr><td><code>WireProtocolVersionNotSupported</code></td><td>4</td><td>Requested version is not supported by the backend</td></tr>
<tr><td><code>ProviderNotRegistered</code></td><td>5</td><td>No provider registered for the requested provider ID</td></tr>
<tr><td><code>ProviderDoesNotExist</code></td><td>6</td><td>No provider defined for requested provider ID</td></tr>
<tr><td><code>DeserializingBodyFailed</code></td><td>7</td><td>Failed to deserialize the body of the message</td></tr>
<tr><td><code>SerializingBodyFailed</code></td><td>8</td><td>Failed to serialize the body of the message</td></tr>
<tr><td><code>OpcodeDoesNotExist</code></td><td>9</td><td>Requested operation is not defined</td></tr>
<tr><td><code>ResponseTooLarge</code></td><td>10</td><td>Response size exceeds allowed limits</td></tr>
<tr><td><code>AuthenticationError</code></td><td>11</td><td>Authentication failed</td></tr>
<tr><td><code>AuthenticatorDoesNotExist</code></td><td>12</td><td>Authenticator not supported</td></tr>
<tr><td><code>AuthenticatorNotRegistered</code></td><td>13</td><td>Authenticator not supported</td></tr>
<tr><td><code>KeyInfoManagerError</code></td><td>14</td><td>Internal error in the Key Info Manager</td></tr>
<tr><td><code>ConnectionError</code></td><td>15</td><td>Generic input/output error</td></tr>
<tr><td><code>InvalidEncoding</code></td><td>16</td><td>Invalid value for this data type</td></tr>
<tr><td><code>InvalidHeader</code></td><td>17</td><td>Constant fields in header are invalid</td></tr>
<tr><td><code>WrongProviderUuid</code></td><td>18</td><td>The UUID vector needs to only contain 16 bytes</td></tr>
<tr><td><code>NotAuthenticated</code></td><td>19</td><td>Request did not provide a required authentication</td></tr>
<tr><td><code>BodySizeExceedsLimit</code></td><td>20</td><td>Request length specified in the header is above defined limit</td></tr>
</tbody></table>
<h2><a class="header" href="#psa-response-status-codes" id="psa-response-status-codes">PSA Response Status Codes</a></h2>
<p>These codes originate from within the <code>Provide</code> trait implementation.</p>
<table><thead><tr><th>Response Status Code</th><th>Value</th><th>Descrption</th></tr></thead><tbody>
<tr><td><code>PsaErrorGenericError</code></td><td>1132</td><td>An error occurred that does not correspond to any defined failure cause</td></tr>
<tr><td><code>PsaErrorNotPermitted</code></td><td>1133</td><td>The requested action is denied by a policy</td></tr>
<tr><td><code>PsaErrorNotSupported</code></td><td>1134</td><td>The requested operation or a parameter is not supported by this implementation</td></tr>
<tr><td><code>PsaErrorInvalidArgument</code></td><td>1135</td><td>The parameters passed to the function are invalid</td></tr>
<tr><td><code>PsaErrorInvalidHandle</code></td><td>1136</td><td>The key handle is not valid</td></tr>
<tr><td><code>PsaErrorBadState</code></td><td>1137</td><td>The requested action cannot be performed in the current state</td></tr>
<tr><td><code>PsaErrorBufferTooSmall</code></td><td>1138</td><td>An output buffer is too small</td></tr>
<tr><td><code>PsaErrorAlreadyExists</code></td><td>1139</td><td>Asking for an item that already exists</td></tr>
<tr><td><code>PsaErrorDoesNotExist</code></td><td>1140</td><td>Asking for an item that doesn't exist</td></tr>
<tr><td><code>PsaErrorInsufficientMemory</code></td><td>1141</td><td>There is not enough runtime memory</td></tr>
<tr><td><code>PsaErrorInsufficientStorage</code></td><td>1142</td><td>There is not enough persistent storage available</td></tr>
<tr><td><code>PsaErrorInssuficientData</code></td><td>1143</td><td>Insufficient data when attempting to read from a resource</td></tr>
<tr><td><code>PsaErrorCommunicationFailure</code></td><td>1145</td><td>There was a communication failure inside the implementation</td></tr>
<tr><td><code>PsaErrorStorageFailure</code></td><td>1146</td><td>There was a storage failure that may have led to data loss</td></tr>
<tr><td><code>PsaErrorHardwareFailure</code></td><td>1147</td><td>A hardware failure was detected</td></tr>
<tr><td><code>PsaErrorInsufficientEntropy</code></td><td>1148</td><td>There is not enough entropy to generate random data needed for the requested action</td></tr>
<tr><td><code>PsaErrorInvalidSignature</code></td><td>1149</td><td>The signature, MAC or hash is incorrect</td></tr>
<tr><td><code>PsaErrorInvalidPadding</code></td><td>1150</td><td>The decrypted padding is incorrect</td></tr>
<tr><td><code>PsaErrorCorruptionDetected</code></td><td>1151</td><td>A tampering attempt was detected</td></tr>
<tr><td><code>PsaErrorDataCorrupt</code></td><td>1152</td><td>Stored data has been corrupted</td></tr>
</tbody></table>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#wire-protocol" id="wire-protocol">Wire Protocol</a></h1>
<h2><a class="header" href="#introduction-2" id="introduction-2">Introduction</a></h2>
<p>This document describes and specifies the wire protocol that exists between the service and its
clients. It explains the general principles of how the protocol is structured, and goes on to
provide a full specification that can be used as the basis of both client-side and service-side
code.</p>
<h2><a class="header" href="#status-note-2" id="status-note-2">Status Note</a></h2>
<p>This is preliminary documentation. It may be incomplete, and is subject to change without notice.</p>
<h2><a class="header" href="#scope" id="scope">Scope</a></h2>
<p>This document describes the principles, patterns and low-level details of the wire protocol. This
covers the details that are common to all messages that pass between the service and its clients.
This document is <em>not</em> an API specification for the service. Individual API operations, along with
their behaviours, inputs and outputs are described separately in the API specification. The wire
protocol is the underlying message-passing mechanism that enables the API.</p>
<h2><a class="header" href="#audience-1" id="audience-1">Audience</a></h2>
<p>A thorough understanding of the wire protocol is necessary if you are developing new capabilities
within certain parts of the service, or if you are developing or extending one of its client
libraries. However, it is not necessary to understand the wire protocol in order to consume the
client API into an application.</p>
<h2><a class="header" href="#general-principles" id="general-principles">General Principles</a></h2>
<h3><a class="header" href="#binary-protocol" id="binary-protocol">Binary Protocol</a></h3>
<p>The wire protocol is a <a href="https://en.wikipedia.org/wiki/Binary_protocol"><strong>binary</strong></a> and
<strong>stream-oriented</strong> protocol. It is designed for speed and compactness of transmission.</p>
<h3><a class="header" href="#requests-and-responses" id="requests-and-responses">Requests and Responses</a></h3>
<p>The wire protocol is principally structured around the notion of a <strong>request</strong> and a <strong>response</strong>.
Requests and responses are self-contained pairs of entities, where each request is answered by
exactly one response. Requests always travel from the client to the service, and responses always
travel back from the service to the client. Each pair of request and response encapsulates a single
call to a single operation provided by the service. Client library code is concerned with forming
requests and transmitting them to the service. Service code is concerned with processing requests,
forming responses, and transmitting those responses back to the client. The term <strong>message</strong> is used
to refer generically to requests and responses in contexts where there is no need to draw a
distinction between them.</p>
<h3><a class="header" href="#analogy-with-http-and-rest" id="analogy-with-http-and-rest">Analogy With HTTP and REST</a></h3>
<p>The request-response pattern of the wire protocol is intentionally modelled on the familiar notion
of calling a REST API over HTTP. In fact, one of the guiding principles of the wire protocol design
has been to create something that might loosely be called a &quot;lightweight REST&quot;. This term must be
applied with caution, however. REST is a collection of architectural principles, not a protocol. It
does not follow that all of the RESTful principles are adopted here. However, thinking of the wire
protocol as being like a web service protocol, only without any dependency on HTTP or similar
stacks, can be a good way to gain an initial understanding. Some patterns of the wire protocol
design have their foundation in a mixture of concepts taken from HTTP and REST, but the wire
protocol itself is neither of these things: it is an entirely bespoke protocol.</p>
<h3><a class="header" href="#synchronous-operation" id="synchronous-operation">Synchronous Operation</a></h3>
<p>The wire protocol operation is synchronous: the client initiates a connection and transmits a
request. It then blocks while the service performs the request and transmits the response on the
return stream. The protocol therefore only supports short-lived operations (meaning that the
fulfillment time must be well within any timeout limitations that the transport might impose). The
protocol can support longer-lived operations, but it is the responsibility of the service API to
define how these are managed. There could, for example, be a pattern whereby there are separate
initiation and status polling operations.</p>
<h3><a class="header" href="#separation-of-protocol-and-transport" id="separation-of-protocol-and-transport">Separation of Protocol and Transport</a></h3>
<p>The wire protocol defines the format of messages, and some key characteristics and invariants
concerning their transmission between the service and its clients. It does not mandate a specific
transport stack. The wire protocol is a binary, stream-oriented protocol. As such, it can be carried
by any transport medium that supports the reliable transmission of binary octet streams, such as
Unix domain sockets (connected in streaming mode) or TCP sockets. Datagram-oriented transports are
<strong>not</strong> supported, because the protocol depends on the reliable transmission of entire messages in
the proper sequence.</p>
<h3><a class="header" href="#separation-of-header-and-body" id="separation-of-header-and-body">Separation of Header and Body</a></h3>
<p>Every message (whether request or response) has a <strong>header</strong> and a <strong>body</strong>. Again, this is
conceptually similar to the separation of header and body in HTTP. And, like HTTP, this protocol
allows some flexibility in how the body content is encoded. The wire protocol borrows HTTP's notion
of the <strong>content-type</strong> and <strong>accept</strong> header fields, which allow the client to tell the server how
to interpret the content, and also to declare what kind of response is acceptable in return. The
only difference is that the wire protocol uses numerical byte fields to indicate these values, where
HTTP uses string key-value pairs and media types. This is another illustration of how the wire
protocol can be viewed as a more compact and stripped-down HTTP.</p>
<p>The message headers are <strong>fixed-length</strong> and <strong>fixed-format</strong>. The headers themselves have no
variability in their encoding, nor do they adhere to any encoding or serialization standard. The
format of the header is defined solely by this specification. When writing code to either transmit
or receive a header, the code must be written and validated according to this specification alone.
Headers are composed of a series of single-byte and multi-byte fields.</p>
<p>The header format is specified to be identical for requests and responses. Request and response
headers are of identical size, and have identical fields specified at identical offsets. This means
that developers only need to understand and code to a single header format. This design also means
that shared memory transport technologies can be used where the header resides in a single shared
buffer. However, this design does also means that some fields are redundant depending on the
context. A full specification of the byte fields for the header will be found later in this
document, including information about how and when they should be populated or interpreted.</p>
<p>Headers carry a fixed set of metadata fields that are common to all messages. However, they do not
carry any inputs to or outputs from specific API operations. API inputs and outputs are always
carried in the body. Unlike the header, which is always fixed-length and fixed-format, the body can
be both variable-length and variable-format.</p>
<h3><a class="header" href="#protobuf-body" id="protobuf-body">Protobuf Body</a></h3>
<p>As described above, the wire protocol design allows for the message body to be structured and
encoded in a variety of formats. However, in current manifestations of the protocol, only a single
encoding is defined for use in the message bodies, and this encoding is based on <a href="https://developers.google.com/protocol-buffers/"><strong>protocol
buffers</strong></a>, also known as <strong>protobuf</strong>.</p>
<p>For each operation in the API, two separate protobuf message definitions will exist: one for that
operation's inputs, and another for its outputs. The content bytes in a request message can be
converted through protobuf-generated code into a model object for the inputs. Likewise, the content
bytes in a response message can be converted through protobuf-generated code into a model object for
the outputs.</p>
<p>Processing any message is, therefore, a two-phase process: firstly, the header must be processed by
writing code that is conformant with this specification; and secondly, the content must be processed
according to its content type, which is currently always protobuf.</p>
<p>Future manifestations of the wire protocol might support encoding schemes other than protobuf, in
which case the second phase of processing would differ. This is the reason why the protocol design
has granted some flexibility in terms of the message body encoding.</p>
<p>It is worth re-iterating that protobuf encodings are employed only for <em>message bodies</em> and not for
headers. As explained above, headers employ a bespoke binary encoding that is fully defined within
this specification alone. There is no use of protobuf within the header. Headers can be parsed and
generated only by writing code that conforms to this specification document. Again, this permits for
the possibility that a future manifesation might support different encoding schemes.</p>
<h3><a class="header" href="#authentication" id="authentication">Authentication</a></h3>
<p>As described above, all messages in this protocol have a header and a body. If a message is a
request (as opposed to a response), then it will additionally carry a third component: its
<strong>authentication</strong> field.</p>
<p>The wire protocol is agnostic about how the authentication field is interpreted. The request header
measures the size of the field so that the service can consume the correct number of bytes from the
input stream. The request header also includes a one-byte integer label to inform the service how to
interpret the authentication bytes.</p>
<p>Authentication is based on the invariant that all client applications have access to a persistent
unique identifier. This is a string token that allows the assets and actions of one client to be
cleanly separated from those of another. But while this identifier string is the core component of
authentication, there are different ways that it can be used, and consequently there are different
ways for the authentication field to be populated. One simple method is for the client identifier to
be passed directly. But it is also possible to use the identifier as input to an HMAC algorithm over
the content bytes, in which case the authentication field would contain the computed HMAC, rather
than the identifier itself.</p>
<h3><a class="header" href="#sessions" id="sessions">Sessions</a></h3>
<p>The wire protocol supports the notion of sessions, which can be used to allow the client and the
service to track state across multiple API calls. The protocol allocates space within the request
header and the response header for an 8-byte session identifier. Details of how to create and manage
sessions are given in the API specification.</p>
<h3><a class="header" href="#wire-protocol-versions" id="wire-protocol-versions">Wire Protocol Versions</a></h3>
<p>The wire protocol is versioned. It caters for situations where the service and its clients may be
operating at different versions. All messages (requests and responses) carry a major and minor
version number field. Although the design supports having different wire protocol versions, changes
are not expected to happen regularly, and they may not happen at all.</p>
<p>Clients can use the <a href="parsec_client/operations/ping.html">Ping</a> operation to determine what is the highest version of
the protocol that the service support and switch to that one if they want to. Requests made with a
wire protocol version not supported by the service will be sent back a
<code>WireProtocolVersionNotSupported</code> status code response.</p>
<p>Responses will be sent using the same wire protocol version than the requests they originate from.</p>
<p>Please note that the wire protocol version is <strong>not</strong> the mean of finding out the level of support
for specific operations in the API. The ListOpcodes operation should be used, per provider basis, to
determine if an operation is supported by the provider.</p>
<h3><a class="header" href="#opcodes" id="opcodes">Opcodes</a></h3>
<p>All requests contain an unsigned 4-byte integer field called the <strong>opcode</strong>. The opcode is the value
that determines which API operation is being invoked by the requests. Recall that each
request/response pair corresponds to the invocation of exactly one API operation, and each of these
operations is assigned an integer opcode.</p>
<p>The opcode zero is not used and is not valid. The lowest valid opcode is 1, and the highest valid
opcode is (2^32-1). Within this overall numerical range, certain partitions and conventions are
established. Ranges of opcodes must be carefully observed and not abused. Contributing developers
will have the opportunity to claim parts of the numerical range for their own unique features and
operations.</p>
<p>Currently, opcodes 1-999 are reserved for internal service housekeeping operations, and opcodes
1000-1999 are reserved for key management and cryptographic operations corresponding to those of the
Platform Security Architecture (PSA) Cryptography API.</p>
<p>Opcodes from 2000 onwards are currently unused and unreserved. No service or client code may be
contributed that uses such opcodes. Please see the contribution guidelines for further information.</p>
<p>All opcodes are defined within the API specification.</p>
<h3><a class="header" href="#status" id="status">Status</a></h3>
<p>All responses contain an unsigned 2-byte integer field called the <strong>status</strong>, which is defined to
indicate the overall success or failure of the operation.</p>
<p>The status value of zero is used universally to mean that the operation completed successfully.</p>
<p>With the exception of zero as a special case, other status values are partitioned according to the
same strategy as the opcodes. Status values from 1-999 are reserved for internal service
housekeeping operations, and status values from 1000-1999 are reserved for status codes
corresponding to the Platform Security Architecture (PSA) Cryptography API.</p>
<p>All status values and their definition can be found on the <a href="parsec_client/status_codes.html"><strong>Status Codes</strong></a> page.</p>
<h2><a class="header" href="#message-structure-specifications" id="message-structure-specifications">Message Structure Specifications</a></h2>
<h3><a class="header" href="#general-rules" id="general-rules">General Rules</a></h3>
<p>This section provides a complete specification for the interpretation of messages. Based on this
specification, service and client code can be created to both consume and produce conformant
messages on any suitable transport medium.</p>
<p>All multi-byte numerical fields are transported in <strong>little-endian</strong> format.</p>
<h3><a class="header" href="#the-fixed-common-header" id="the-fixed-common-header">The Fixed Common Header</a></h3>
<p>Requests and responses share a common fixed-format header whose specification is given below.
Because the header format is the same for requests and responses, it means that some of the data
fields in the header are unused/ignored depending on whether the header is an outgoing request
(being transmitted from the client to the service), or an incoming response (being returned from the
service back to the client). However, most fields are relevant and common to both.</p>
<p>Each field is annotated according to the following scheme:</p>
<ul>
<li>The annotation <em>common</em> indicates that the field is common to both request messages and response
messages.</li>
<li>The annotation <em>requests only</em> indicates that the field is only used in requests and may be
ignored in responses.</li>
<li>The annotation <em>responses only</em> indicates that the field is only used in responses and may be
ignored in requests.</li>
</ul>
<p>Fields occur in contiguous memory and there must be no additional padding between them.</p>
<p><img src="parsec_client/diagrams/wire_header.png" alt="Header Structure" /></p>
<p>Field descriptions:</p>
<ul>
<li>Magic number (<em>common</em>): a 32-bit unsigned integer whose value must be 0x5EC0A710 (selected to be
an approximate transcoding of SECurity API). This field can be used as an initial validity check
for incoming messages. This field <strong>must</strong> be populated in all messages. This field will remain
the same across different wire protocol versions.</li>
<li>Header size (<em>common</em>): a 16-bit unsigned integer whose value is the size of the <strong>remainder</strong> of
the header in bytes (once the magic number and header size fields have been consumed). Consumers
<strong>must</strong> use this field to consume the correct number of bytes of header from the input stream,
rather than use this specification to deduce the header size. This field's position and width
will remain the same across different wire protocol versions. Only the value of this field may
change between versions.</li>
<li>Major version number (<em>common</em>): an 8-bit versioning field. Currently the only supported and valid
value for this field is 1. This field's position and width will remain the same across different
wire protocol versions. Only the value of this field may change between versions.</li>
<li>Minor version number (<em>common</em>): an 8-bit versioning sub-field. Currently the only supported and
valid value for this field is 0. This field's position and width will remain the same across
different wire protocol versions. Only the value of this field may change between versions.</li>
<li>Flags (<em>common</em>): a 16-bit field that is currently unused and should be set to zero.</li>
<li>Provider (<em>common</em>): an 8-bit field identifying the back-end service provider for which the
request is intended. A value of zero indicates that the request is intended for a special
provider, which always exists, and is used for service discovery and communication bootstrapping.</li>
<li>Session handle (<em>common</em>): a 64-bit session identifier.</li>
<li>Content type (<em>common</em>): an 8-bit field that defines how the request body should be processed. The
only currently-supported value is 1, which indicates that the request body should be treated as a
serialized protobuf message.</li>
<li>Accept type (<em>requests only</em>): an 8-bit field that defines how the service should provide its
response. The only currently-supported value is 1, which indicates that the service should
provide a response whose body is a serialized protobuf message.</li>
<li>Auth type (<em>requests only</em>): an 8-bit field that defines how the authentication bytes should be
interpreted.</li>
<li>Content length (<em>common</em>): a 32-bit unsigned integer field providing the exact number of bytes of
content.</li>
<li>Auth length (<em>requests only</em>): a 16-bit unsigned integer field providing the exact number of bytes
of authentication.</li>
<li>OPCODE (<em>common</em>): the 32-bit unsigned integer opcode, indicating the operation being performed by
this request. See the section above on opcodes.</li>
<li>STATUS (<em>responses only</em>): the 16-bit unsigned integer status, indicating the overall success or
failure of the operation. A value of zero is used universally to mean success. Other values
should be interpreted according to the API specification.</li>
<li>RESERVED (<em>common</em>): a 16-bit field that is currently unused and must be set to zero.</li>
</ul>
<h3><a class="header" href="#requests" id="requests">Requests</a></h3>
<p>A request message begins with the fixed-format header as specified above, followed contiguously by a
variable-length field of zero or more <strong>message body</strong> bytes, which is in turn followed contiguously
in memory by a variable-length field of zero or more <strong>authentication</strong> bytes.</p>
<p>The interpretation of the body and authentication bytes is specified by the relevant fields in the
fixed-format header.</p>
<p>The request body bytes <strong>must</strong> immediately follow the request header bytes, and the size of the
body must precisely match the Content Length field of the header with no additional padding or
alignment.</p>
<p>The authentication bytes <strong>must</strong> immediately follow the request body bytes, and the size of the
authentication field must precisely match the Auth Length field of the header with no additional
padding or alignment.</p>
<p><img src="parsec_client/diagrams/wire_request.png" alt="Wire Request" /></p>
<h3><a class="header" href="#responses" id="responses">Responses</a></h3>
<p>A response message begins with the fixed-format header as specified above, followed contiguously by
a variable-length field of zero or more <strong>message body</strong> bytes.</p>
<p>The interpretation of the body is specified by the relevant fields in the fixed-format header.</p>
<p>The response body bytes <strong>must</strong> immediately follow the response header bytes, and the size of the
body must precisely match the Content Length field of the header with no additional padding or
alignment.</p>
<p><img src="parsec_client/diagrams/wire_response.png" alt="Wire Response" /></p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#writing-a-new-parsec-client-library" id="writing-a-new-parsec-client-library">Writing a new Parsec Client Library</a></h1>
<p>If a client library does not already exist in your preferred programming language, you can create
one. Writing a new client library is a great way to enhance the Parsec client ecosystem.</p>
<p>When creating a new client library, please make sure you understand the <a href="parsec_client/../overview.html#beautiful-client-libraries">Parsec philosophy for
client libraries</a>. It is very important that you design
your client library to provide a highly ergonomic and idiomatic developer experience.</p>
<p>You will need to understand the <a href="parsec_client/wire_protocol.html"><strong>wire protocol specification</strong></a> and the <a href="parsec_client/api_overview.html"><strong>API
specification</strong></a> in depth in order to create a client library.</p>
<p>You will need to know which <a href="parsec_client/../parsec_service/listeners.html"><code>Listener</code></a> the Parsec service is
currently using and how it was configured in order to communicate with it.</p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#parsec-for-service-developers" id="parsec-for-service-developers">Parsec for service developers</a></h1>
<p>Find in this sections guides for those looking to work hands-on with the Parsec service source code.
They cover the following concepts:</p>
<ul>
<li><a href="parsec_service/system_architecture.html">System Architecture</a> - overview of the Parsec system architecture,
including all external components needed for correct operation</li>
<li><a href="parsec_service/interfaces_and_dataflow.html">Interfaces and Dataflow</a> - description of all the components forming
the Parsec service and their interactions</li>
<li><a href="parsec_service/source_code_structure.html">Source Code Structure</a> - overview of Parsec service source code
organisation</li>
<li><a href="parsec_service/providers.html">Parsec Providers</a> - overview of current Parsec providers</li>
<li><a href="parsec_service/converters.html">Parsec Converters</a> - overview of current Parsec converters</li>
<li><a href="parsec_service/authenticators.html">Parsec Authenticators</a> - overview of current Parsec authenticators</li>
<li><a href="parsec_service/listeners.html">Parsec Listeners</a> - overview of current Parsec listeners</li>
<li><a href="parsec_service/key_info_managers.html">Parsec Key Info Managers</a> - overview of current Parsec key info managers</li>
<li><a href="parsec_service/adding_provider.html">Writing a Provider</a> - guide for implementing a new provider that will add
Parsec support for new platforms</li>
<li><a href="parsec_service/build_run.html">Building and Running</a> - description of the options that can be used for building
and running the service</li>
<li><a href="parsec_service/install_parsec_linux.html">Installation</a> - installing Parsec as a systemd daemon</li>
<li><a href="parsec_service/configuration.html">Configuration</a> - how to configure Parsec</li>
<li><a href="parsec_service/test.html">Testing</a> - details about the kinds of tests we employ and how to set up your environment
in preparation for running them</li>
</ul>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#system-architecture" id="system-architecture">System Architecture</a></h1>
<h2><a class="header" href="#introduction-3" id="introduction-3">Introduction</a></h2>
<p>This document sets out a system architecture for a deployment of the security service as part of a
complete system where it can be used by client applications. This system architecture is constructed
around an example deployment where the applications are running in containers within a shared
operating system kernel (without full virtualisation). This is not the only possible deployment
pattern, and many of the concepts in this document could be adapted to suit other deployments.</p>
<h2><a class="header" href="#status-note-3" id="status-note-3">Status Note</a></h2>
<p>This is preliminary documentation. It may be incomplete, and is subject to change without notice.</p>
<h2><a class="header" href="#overview" id="overview">Overview</a></h2>
<p>The security service provides an API to key storage and cryptographic operations. This API is based
on the <a href="https://github.com/ARMmbed/mbed-crypto/blob/psa-crypto-api/docs/PSA_Cryptography_API_Specification.pdf"><strong>PSA Crypto API
Specification</strong></a>.
The API is exposed to clients over a transport medium using a <a href="parsec_service/../parsec_client/wire_protocol.html"><strong>wire
protocol</strong></a>, so that it can be consumed by client applications in
multiple programming languages, residing in separate processes on the shared physical host. The
security service is a <strong>multi-tenant</strong> service. It isolates and partitions the key store such that
secure assets provisioned by one client application cannot be used by another. This isolation can
only be achieved if every client application is able to present a unique and stable identity to the
security service. This identity also has to be validated on the host system, so that client
applications can prove their identity and therefore authenticate themselves to use the security
service.</p>
<p>The distribution and validation of client identitites is a vital part of the overall deployment of
the system. This system architecture sets out one possible way in which this can be achieved
end-to-end.</p>
<p>The goal of this or any system architecture is to show how any client application can call an
individual cryptographic operation, such that the security service can not only trust the source of
the call, but also perform it with the required degree of isolation from other clients.</p>
<p>Isolation is based on the critical concept of an <strong>application identity</strong>. An application identity
is a canonical string value, akin to a namespace, which is used to partition all storage (whether
persistent or ephemeral) and all activities within the security service. Application identities are
unique per client application. They are stable across application restarts, system restarts, and
component upgrades.</p>
<p>The system architecture enables each client application to pass its application identity to the
security service in a way that is cryptographically proven end-to-end. This allows the security
service to trust the caller's identity, and to implement the required isolation. The architecture
achieves this by placing the security service alongside some additional components that understand
the client application lifecycle and are able to both provide and prove the identity string for each
client.</p>
<p>The system architecture document is structured as follows:</p>
<ul>
<li>A set of <strong>design goals</strong> is established to act as guiding principles and constraints for the
architecture.</li>
<li>The <strong>participating components</strong> are listed along with a definition of their roles within the
system. Note that the security service is the only component whose implementation is contained in
this source code repository. Additional components are implemented separately. This document only
sets out the required roles and contracts of those additional components. Their precise
implementation can depend on the deployment.</li>
<li>The <strong>trust relationships</strong> are described in terms of how they are established and maintained, and
also in terms of which components share such relationships.</li>
<li>The <strong>trusted data payloads</strong> are described. These are the data objects that are subject to
cryptographic signing and verification according to the defined trust relationships.</li>
<li>Finally, the <strong>flows</strong> of data between components are captured in a sequence diagram, which shows
how the system is bootstrapped and then used on an ongoing basis.</li>
</ul>
<h2><a class="header" href="#design-goals" id="design-goals">Design Goals</a></h2>
<p>The system architecture aims to address the following design goals and constraints:</p>
<ul>
<li>The system should be <strong>fault tolerant</strong> in general, but specifically with respect to any transient
loss or restart of any of the participating components. If one component restarts, then other
components should be able to recover their ability to communicate with it, such that there is no
loss of functionality across the system as a whole. It is acceptable for sub-optimal performance
to be incurred for a transient period during recovery.</li>
<li>Communication channels should be <strong>stateless</strong>. This is partly to address the fault-tolerance
requirement set out above, but also because it is generally considered to be good practice in
service-oriented architectures of which this system is an example. The participating components
will necessarily have their own internal state where needed, both persistent and ephemeral. The
security service, for example, has at least one store for secure assets (such as keys). But
components should not rely on shared state without an ability to re-synchronize that state at
arbitrary times.</li>
<li>Communication channels should be <strong>secretless</strong>. Passing private keys or other secrets across wire
protocol interfaces is forbidden. Only public keys or other non-confidential assets can be
passed.</li>
<li>Components should store any secret data <strong>in local process memory only</strong>, unless there is an
overriding requirement for it to be stored persistently. Trust relationships between components
need to be re-established (by sharing the public part of a new key pair) in the case where a
component is restarted.</li>
<li>The system should be <strong>cryptographically secure</strong>. A cryptographically-provable mechanism must
exist in the communication channels between components.</li>
<li>Cryptographic security should be established on a <strong>short-lived</strong> basis. Trust between components
must be refreshed periodically.</li>
</ul>
<h2><a class="header" href="#participating-components-and-their-roles" id="participating-components-and-their-roles">Participating Components and their Roles</a></h2>
<p>The system architecture defines the following participating components, all of which are assumed to
co-reside on the same physical host:</p>
<ul>
<li>The <strong>client application</strong> is the ultimate consumer of the security API. Any number of client
applications can share the same physical host. They can be written in different programming
languages, and reside across multiple containers or processes. The functionality of each client
application is arbitrary, and the only thing that they have in common is their shared requirement
to access the cryptographic services of the host platform. Client applications should not be
confused with processes or containers. It is possible for a single client application to be
spread across multiple processes or containers. Conversely, it is possible for a single process
or container to house multiple client applications. The boundary between client applications is a
security boundary that is defined and arbitrated by other components in the system.</li>
<li>The <strong>client library</strong> is a convenience layer that provides a simplified and idiomatic way to
access the security API in a specific programming language. The client library is loaded by the
client application and shares its address space. Communications between the client application
and the client library are in-process and in-language procedure calls with no IPC. There is one
client library per supported programming language. Client libraries are more than just bindings.
Each one offers a highly-designed developer experience tailored to the programming language,
providing the API in a form that is simple to consume and hard to get wrong. This means that it
has facilities for things like smart defaulting, so that the client application can call APIs
with fewer arguments and simplified contracts that are tailored for specific use cases. The
client library is then fundamentally an adaptor or wrapper: it converts between the simplified
developer experience and the comprehensive API definition based on the PSA Crypto API. It makes
calls to the security service according to the defined <a href="parsec_service/../parsec_client/wire_protocol.html"><strong>wire protocol
specification</strong></a>.</li>
<li>The <strong>orchestrator</strong> is the component that manages the lifecycle of the client applications on the
physical host. It is responsible for starting and stopping their containers or processes. In a
containerized environment on a Linux system, a daemon such as
<a href="https://docs.docker.com/engine/reference/commandline/dockerd/"><strong>dockerd</strong></a> would naturally
assume the role of the orchestrator in this system architecture. A single instance of the
orchestrator runs on the host system.</li>
<li>The <strong>security service</strong> is the component that provides the API to the cryptographic services of
the host platform. This API is based on the <a href="https://github.com/ARMmbed/mbed-crypto/blob/psa-crypto-api/docs/PSA_Cryptography_API_Specification.pdf"><strong>PSA Crypto API
Specification</strong></a>.
A single instance of this service runs on the host system (deployed, for example, as a daemon).
It listens on a suitable host-local transport medium such as a Unix domain socket and exposes a
<a href="parsec_service/../parsec_client/wire_protocol.html"><strong>wire protocol</strong></a> with a <a href="parsec_service/../parsec_client/api_overview.html"><strong>defined
API</strong></a>. The inner architecture of the service is described in
the other documents in this repository.</li>
<li>The <strong>identity provider</strong> is the component that assigns unique and stable application identities
to each client application. Any string that can be used persistently and unambiguously to refer
to one and only one client application is suitable. This system architecture proposes the use of
a Uniform Resource Identifier (URI), such as the identity scheme used by
<a href="https://spiffe.io"><strong>SPIFFE</strong></a>. The identity provider receives application lifecycle events from
the orchestrator, and these events contain enough information for the identity provider to deduce
the application identity and return it to client applications on request. The identity provider
is fundamentally a mapping service, with orchestrator data as its input and application
identities as its output. The identity provider exposes the same <a href="parsec_service/../parsec_client/wire_protocol.html"><strong>wire
protocol</strong></a> as the security service, albeit with a different
set of APIs to reflect its very different role.</li>
<li>The <strong>crypto provider</strong> is a back-end software module within the security service that interfaces
with the hardware or software facilities of the platform in order to implement key storage and
cryptographic operations. Within the service itself, these modules are simply called &quot;providers&quot;,
but the term &quot;crypto provider&quot; is used here to avoid confusion with the identity provider
component. Crypto providers provide access to hardware facilities such as Trusted Platform
Modules (TPMs) or Hardware Security Modules (HSMs). Alternatively, they might interact with
software components running in a Trusted Execution Environment (TEE), or secure enclave, if the
host platform supports them. Their implementations would vary considerably depending on the
platforms, and these details are largely irrelevant to the system architecture. They are included
here largely for completeness, since they are the ultimate provider of the cryptographic services
being consumed by the client applications.</li>
</ul>
<h2><a class="header" href="#trust-relationships" id="trust-relationships">Trust Relationships</a></h2>
<p>This section outlines the trust relationships that exist between components, how they are
established, and how they are maintained over the component lifetimes. This section covers only
those trust relationships that are material to the system architecture: other trust relationships
might exist in the system for various reasons.</p>
<p>The trust relationships detailed below are always established between pairs of components: the
<strong>trusted component</strong> and the <strong>trusting component</strong>. They are based on <strong>asymmetric digital
signatures</strong>. They rely on trusted component being able to sign some data such that the trusting
component can verify it.</p>
<ul>
<li>The trusted component generates a <strong>root key-pair</strong>.</li>
<li>The trusted component maintains the <strong>root private key</strong> in process-local memory only. The private
key is not shared with any other component, nor is it stored persistently.</li>
<li>The trusted component sends the <strong>root public key</strong> to the trusting component as an X509
certificate. This is done by making an API call according to the conventions of the <a href="parsec_service/../parsec_client/wire_protocol.html"><strong>wire
protocol specification</strong></a>. This is strictly a one-time
operation, and this must be enforced by the trusting component. Any attempt to send revised root
keys must be rejected. For more information, refer to the
<a href="parsec_service/../parsec_client/operations/share_trust_bundle.html"><strong>ShareTrustBundle</strong></a> operation in the API
reference.</li>
<li>On a periodic basis, the trusted component generates a new <strong>intermediate key pair</strong>, and once
again keeps the private key in process-local memory only.</li>
<li>On each periodic refresh, the trusted component sends a new <strong>intermediate public key</strong> to the
trusting component, again as an X509 certificate. (This allows the trusting component to view the
intermediate certificate and the root certificate as a chain).</li>
<li>In general communication, the trusted component will use its private key to sign data, and the
trusting component will use the public certificate chain to verify it. If verification passes,
then the data can be trusted.</li>
</ul>
<p>The term &quot;root&quot; here should be qualified, since any root key or certificate is only a root from the
perspective of this system architecture. This does not exclude the possibility that these roots are
themselves part of a longer trust chain involving an external Certificate Authority (CA).
Integrations with external CAs are outside of the scope of this document. The term &quot;root&quot; should
always be considered with this qualification in mind.</p>
<p>In this system architecture, two trust relationships exist, each of which is established and
maintained according to the scheme described above. The trust relationships are as follows:</p>
<ul>
<li>Between the <strong>orchestrator</strong> and the <strong>identity provider</strong>. In this case, the orchestrator is the
trusted component and the identity provider is the trusting component. The need for a trust
relationship here is due to the orchestrator being a presenter of client definitions and proofs
to the identity provider.</li>
<li>Between the <strong>identity provider</strong> and the <strong>security service</strong>. In this case, the identity
provider is the trusted component and the security service is the trusting component. The need
for this trust relationship is to allow the identity provider to sign authentication tokens on
behalf of each client, such that the security service can verify those tokens and permit an API
call to proceed.</li>
</ul>
<h2><a class="header" href="#wire-protocols" id="wire-protocols">Wire Protocols</a></h2>
<p>Both the identity provider and the security service expose an API endpoint based on the common
<a href="parsec_service/../parsec_client/wire_protocol.html"><strong>wire protocol specification</strong></a>. However, the roles of these
two components are very different, and it follows that the set of API operations offered by each
endpoint will be likewise different. In the case of the security service, the majority of its API
operations are for key storage and cryptography, and are based on the PSA Crypto API. In the case of
the identity provider, a much smaller set of operations are needed, and these enable the sharing of
client definitions and proofs.</p>
<p>The only part of the API that is common between the two components is the
<a href="parsec_service/../parsec_client/operations/share_trust_bundle.html"><strong>ShareTrustBundle</strong></a> operation, which is used
to establish and maintain trust relationships.</p>
<p>The identity provider additionally offers the
<a href="parsec_service/../parsec_client/operations/add_client.html"><strong>AddClient</strong></a> and
<a href="parsec_service/../parsec_client/operations/prove_client.html"><strong>ProveClient</strong></a> operations, which allow the
orchestrator to inform the identity provider about the lifecycle of client applications. This small
operation set represents the entirety of the identity provider's API.</p>
<p>By contrast, the security service exposes the full capabilities of the PSA Crypto API.</p>
<h2><a class="header" href="#trusted-data-payloads" id="trusted-data-payloads">Trusted Data Payloads</a></h2>
<p>A trusted data payload is any data payload that is signed and verified according to one of the
defined trust relationships. Since two trust relationships are defined in this system architecture,
it follows that a trusted data payload is either a payload that is signed by the orchestrator and
verified by the identity provider, or it is a payload that is signed by the identity provider and
verified by the security service. This section outlines the trusted data payloads that are subject
to such sign-and-verify procedures.</p>
<h3><a class="header" href="#client-definitions" id="client-definitions">Client Definitions</a></h3>
<p>The system architecture requires each client application to have an identity that is unique and
stable. This requirement for stability is especially important given that many low-level
characteristics of a client application may change over time. Process identifiers, for example, can
change as a client application restarts. Even the contents of a client application image can change
due to an upgrade. So a client application needs to be able to present enough pieces of information
to the identity provider in order for the identify provider to make a binding decision about the
identity.</p>
<p>These pieces of information are collected together into what is called a <strong>client definition</strong>.</p>
<p>There can be no fixed set of properties that would make an adequate client definition in any
environment. The system architecture only requires that the orchestrator and the identity provider
are able to agree on what the client definition should be. Client definition is essentially a
contract between those two components. An example of a client definition might be a JSON document
containing properties such as the container image identifier, host identifier and kernel namespace.</p>
<p>Client definition formats are agreed between the orchestrator and the identity provider on any given
system. A JSON or similar structure would be typical. The client definition is constructed by the
orchestrator, and notified to the identity provider at key lifecycle points such as client start-up
or shut-down. (More details are given in the section on dataflows below).</p>
<p>Client definitions, regardless of their precise format and content, must be signed by the
orchestrator and verified upon receipt by the identity provider. The orchestrator will use its own
private key for signing, and verification will be via the shared public key. See the section above
on trust relationships for details of how these keys are generated and shared.</p>
<h3><a class="header" href="#client-proofs" id="client-proofs">Client Proofs</a></h3>
<p>A client definition is essentially a set of claims. By presenting a client definition, the client
application is asserting its worthiness to be assigned a particular identity string by the identity
provider. In order for these claims to be made valid inputs to the mapping process, the identity
provider needs to be able to trust them. They cannot simply be asserted. They must also be
<strong>proved</strong>. Proofs are obtained through an attestation process, the precise details of which are
beyond the scope of this document, but illustrative examples might be:</p>
<ul>
<li>Supply-chain proofs, such as an image signature or signatures on component binaries.</li>
<li>Host proofs, such as might be derived from a platform root-of-trust.</li>
<li>Runtime proofs, such as process identifiers, user/group identifiers, kernel namespaces or
application-specific key pairs.</li>
</ul>
<p>As with client definitions, client proofs must be signed by the orchestrator and verified upon
receipt by the identity provider. The orchestrator will use its own private key for signing, and
verification will be via the shared public key. See the section above on trust relationships for
details of how these keys are generated and shared.</p>
<h3><a class="header" href="#authentication-tokens" id="authentication-tokens">Authentication Tokens</a></h3>
<p>When client applications invoke API operations in the security service, they must include their
application identity string somehow. This allows the security service to provide the required level
of isolation amongst the multiple clients that might exist. Not only must the identity string be
specified, but it must be specified in a way that allows the security service to be sure that it is
genuine. Client applications do this by means of an <strong>authentication token</strong>.</p>
<p>The <a href="parsec_service/../parsec_client/wire_protocol.html"><strong>wire protocol specification</strong></a> has an <strong>authentication
header</strong> field that is suited to this purpose. The protocol is very flexible, and the authentication
header can be used in a variety of ways. It would be entirely possible for the client application to
simply pass its application identity directly as a cleartext string. The security service would
support this (and it offers an authentication style known as <strong>direct authentication</strong> for this
purpose). This is simple, and works well in a demo or proof-of-concept environment. But it is not
suitable for a deployed system architecture, because it does not fulfil the stated design goal of
secretless communication.</p>
<p>The solution to this problem is for the authentication header to contain a payload that not only
includes the application identity, but also proves cryptographically that it is from a valid client.
This payload takes the form of a <a href="https://tools.ietf.org/html/rfc7519"><strong>signed JSON Web Token
(JWT)</strong></a>.</p>
<p>The application identity string will be carried as one of the JWT claim fields. (TODO: which one?)
Since the JWT will be signed, this allows the security service to verify that it is genuine, and
thus permit the call to go ahead with the required level of isolation.</p>
<p>JWT tokens are not directly signed by client applications, since client applications do not
participate in any of the trust relationships that this system architecture has defined. Instead,
they are signed by the identity provider, and passed back to the client application in order to
eventually be forwarded to (and verified by) the security service. The identity provider uses its
private key to sign the JWT. The security service has the public part of this key, and is hence able
to perform the verification. The identity provider and the security service share one of the trust
relationships that were defined above.</p>
<h2><a class="header" href="#block-architecture-summary" id="block-architecture-summary">Block Architecture Summary</a></h2>
<p>Refer to the figure below for a block representation of the key architectural components.</p>
<p><img src="parsec_service/diagrams/system_architecture.png" alt="System Architecture Diagram" /></p>
<h2><a class="header" href="#flows" id="flows">Flows</a></h2>
<h3><a class="header" href="#system-lifecycle-boot" id="system-lifecycle-boot">System Lifecycle: Boot</a></h3>
<p>The following bootstrapping actions are needed in order to establish the trust relationships that
exist between the orchestrator and the identity provider, and between the identity provider and the
security service respectively. For more details, see the section above on trust relationships. The
bootstrapping flows require each component to generate a root key pair, to store the private key
part in process-local memory, and to share the public part (as an X509 certificate) with the
trusting component.</p>
<p>Public root certificates are shared using the
<a href="parsec_service/../parsec_client/operations/share_trust_bundle.html"><strong>ShareTrustBundle</strong></a> API operation, with a flag
to indicate that this is a root certificate as opposed to an intermediate. Both the security service
and the identity provider support this operation via the respective (separate) wire protocol
endpoints.</p>
<p>Root certificates may be shared only once. The
<a href="parsec_service/../parsec_client/operations/share_trust_bundle.html"><strong>ShareTrustBundle</strong></a> operation is defined to
fail if it is called more than once with the root flag set.</p>
<h3><a class="header" href="#system-lifecycle-refresh" id="system-lifecycle-refresh">System Lifecycle: Refresh</a></h3>
<p>Background flows occur on a periodic cadence while the system is active, and they are aimed at
maintaining the trust relationships between the orchestrator, identity provider and security
service.</p>
<p>Trust relationships require intermediate key pairs to be generated periodically in order to fulfil
the stated design objective around short-lived cryptography. The root key pairs generated in the
bootstrapping phase do not fulfil this objective by themselves.</p>
<p>Intermediate key pairs are generated by both the orchestrator and identity provider. Each component
stores its private key in local process memory, but needs to share the public key. As with the
bootstrapping flows, the orchestrator shares its public key with the identity provider, and the
identity provider shares its public key with the security service. There is a common API in the wire
protocol to support this operation.</p>
<p>Public intermediate certificates are shared using the
<a href="parsec_service/../parsec_client/operations/share_trust_bundle.html"><strong>ShareTrustBundle</strong></a> API operation, with a flag
to indicate that this is an intermediate certificate as opposed to a root. Both the security service
and the identity provider support this operation via the respective (separate) wire protocol
endpoints.</p>
<p>Intermediate public certificates may be shared any number of times. Any previous intermediate
certificate is immediately invalidated upon the event of a new intermediate being shared.</p>
<h3><a class="header" href="#application-lifecycle" id="application-lifecycle">Application Lifecycle</a></h3>
<p>Client application lifecycles are governed by the orchestrator. The orchestrator is responsible for
starting and stopping the client application containers or processes. It is also responsible for
notifying these events to the identity provider, and for sending the client definitions and client
proofs.</p>
<p>To add a new client definition to the identity provider, the orchestrator calls the
<a href="parsec_service/../parsec_client/operations/add_client.html"><strong>AddClient</strong></a> operation with a signed data payload
containing the client definition properties (typically a JSON document).</p>
<p>Having informed the identity provider of a new client definition, the next role of the orchestrator
is to run an attestation process to prove its validity. The results of the attestation process are
then sent to the identity provider using the
<a href="parsec_service/../parsec_client/operations/prove_client.html"><strong>ProveClient</strong></a> operation, again with a signed data
payload containing the proofs.</p>
<h3><a class="header" href="#general-usage-flows" id="general-usage-flows">General Usage Flows</a></h3>
<p>The final flow to consider is the general use case of the client application making a call to the
security service to perform a cryptographic operation with isolation. This is obviously the most
commonly-occurring flow, and everything else in the system is geared towards enabling this
fundamental operation.</p>
<p>This flow begins with the client application, which consumes the security API via the client
library. Recall that client libraries exist for a variety of popular programming languages. Recall
also that each client library offers a highly-designed developer experience, with appropriate levels
of simplification and argument defaulting so that common cryptographic use cases are catered for
with a minimum of effort on the part of the application developer.</p>
<p>The client library is responsible for implementing the language-specific idioms in terms of one or
more wire protocol API calls to the security service. In order to make these calls, it needs a
signed JWT token that embeds the correct application identity for the client. These tokens come from
the identity provider. Hence the client library must first call the identity provider to obtain this
token. It can then call the security service with the signed token.</p>
<p>The security service is responsible for verifying the token and extracting the application identity
from it. This identity can then be used as a namespace for all secure assets that are stored for
that client.</p>
<p>Once the security service has verified and accepted a call to an API operation, it becomes the
responsibility of the back-end cryptographic provider to actually implement the call either in
software or hardware. Once the operation has been executed, the results can be marshalled back to
the client library, which can once again implement whatever simplifications or interpretations are
required to make them suitable for the application developer.</p>
<h3><a class="header" href="#sequence-diagram" id="sequence-diagram">Sequence Diagram</a></h3>
<p>All flows are summarised and captured in the sequence diagram below. The diagram attempts to collect
together and summarise all of the flows that are needed for bootstrapping, background operations and
also general usage as described above. In order to strike the right balance between completeness and
simplicity, the flow diagram does not include every possible path. In particular, the actions taken
in response to errors or failed verifications are not captured here.</p>
<p><img src="parsec_service/diagrams/ident_provider_seq.png" alt="Sequence Diagram" />.</p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#interfaces-and-dataflow" id="interfaces-and-dataflow">Interfaces and Dataflow</a></h1>
<h2><a class="header" href="#introduction-4" id="introduction-4">Introduction</a></h2>
<p>This document describes the key interfaces and data flows within the service. It can be used in
combination with the <a href="parsec_service/source_code_structure.html"><strong>source code structure</strong></a> and <a href="parsec_service/../parsec_client/wire_protocol.html"><strong>wire
protocol</strong></a> documents to gain an understanding of how API
requests are received by the service and ultimately fulfilled by providers.</p>
<h2><a class="header" href="#status-note-4" id="status-note-4">Status Note</a></h2>
<p>This is preliminary documentation. It may be incomplete, and is subject to change without notice.</p>
<h2><a class="header" href="#data-flow-diagram" id="data-flow-diagram">Data Flow Diagram</a></h2>
<p>The sections within this documentation are best understood with reference to the following data flow
diagram. The shaded areas below can also be used to cross-reference the data flow with the <a href="parsec_service/source_code_structure.html"><strong>source
code structure</strong></a> document, which can help with finding the relevant
definitions and implementations.</p>
<p><img src="parsec_service/diagrams/interfaces_and_dataflow.png" alt="Data Flow Diagram" /></p>
<h2><a class="header" href="#the-data-flow-backbone" id="the-data-flow-backbone">The Data Flow Backbone</a></h2>
<p>The <strong>data flow backbone</strong> refers to the overall flow of a single API request from a client
application, via the client library, through the IPC transport, through the service to a provider,
and then back again. It is captured by the bold red boxes in the flow diagram above. This
fundamental flow is common to all requests, no matter how they are fulfilled. Once a request hits a
back-end provider, it can be processed in an arbitrary number of different ways, using a combination
of hardware and software facilities provided by the target platform. However, the same fundamental
flow is always used to carry the request through the core parts of the service between the provider
and the client application.</p>
<p>There are at least two distinct processes involved in any API interaction: the client application
and the service. The architecture also supports out-of-process co-services that can be spawned as
child processes by the main service, making it possible for a full deployment to involve three or
even more distinct processes. Whenever data is transferred between processes, whether between the
client and the service, or between the service and a co-service, the same wire protocol
specification is always used to transfer the data as a serialized stream of bytes.</p>
<p>Out-of-process providers are supported in the architecture, but are not yet supported in the
implementation. The rationale for out-of-process providers is that it allows for them to be
developed in programming languages other than Rust.</p>
<p>This document concentrates on the data flows within the service. It does so by examining the role of
the key Rust objects, modules and interfaces, and the stages by which they process the request and
return the result.</p>
<h2><a class="header" href="#the-listener" id="the-listener">The Listener</a></h2>
<p>The <code>Listener</code> is responsible for accepting incoming connections from clients on the transport
endpoint. This could take the form of a Unix domain socket listener. It is the only part of the
system that understands the form of transport being used. Its responsibility is to accept
connections and to produce streams capable of reading from and writing to the underlying connection.
The <code>Listener</code> does not perform any serialization or deserialization (marshalling) functions. It
deals only in connections and streams.</p>
<p>The <code>Listener</code> implements the <code>Listen</code> trait. Possible listeners are listed <a href="parsec_service/listeners.html">here</a>.</p>
<h2><a class="header" href="#the-front-end-handler" id="the-front-end-handler">The Front-End Handler</a></h2>
<p>Once an incoming byte stream has been obtained by the <code>Listener</code>, the stream is passed to the
<code>FrontEndHandler</code>, which is where the first phase of wire protocol interpretation is performed. The
<code>FrontEndHandler</code> is responsible for de-serializating the request header using the rules set out in
the <a href="parsec_service/../parsec_client/wire_protocol.html"><strong>wire protocol specification</strong></a>.</p>
<p>The <code>FrontEndHandler</code> only de-serializes the request <em>header</em>. It does <em>not</em> serialize the request
<em>body</em>. The body content is processed at a later step. This means that the <code>FrontEndHandler</code> only
needs to understand the documented encoding scheme of the header format. It does not need to
understand protobuf or any other encoding scheme that might be employed for the body. The
<code>FrontEndHandler</code> makes use of the model objects and de-serialization support in the interface crate
to create a structured data model for the request. In this structured model, the request header
fields are all fully parsed, but the request body and authentication fields are still just arrays of
bytes.</p>
<h3><a class="header" href="#the-authenticator" id="the-authenticator">The Authenticator</a></h3>
<p>Before the request is sent forward it must be authenticated. This involves the <code>FrontEndHandler</code>
choosing an appropriate <code>Authenticator</code> object from the set created at system startup, based on the
<code>AuthType</code> field in the request header. The <code>Authenticator</code> either returns an application name if
the authentication was successful, or an error value which is then returned to the client.</p>
<p>The <code>Authenticator</code> implements the <code>Authenticate</code> trait. Possible authenticators are listed
<a href="parsec_service/authenticators.html">here</a>.</p>
<p>The partially-decoded request and application name are now sent to the <code>Dispatcher</code>.</p>
<h2><a class="header" href="#the-dispatcher" id="the-dispatcher">The Dispatcher</a></h2>
<p>The <code>Dispatcher</code> processes the <code>requests::Request</code> object, which represents a request with a
fully-parsed header, but an unparsed byte array for the body. Since the header is parsed, the
<code>Dispatcher</code> has access to all of the information that is needed to dispatch a request to the
appropriate back-end. This information includes the provider identifier, the body encoding type
(which is currently always <code>protobuf</code>, but in theory could be something else), and the protocol
version major and minor fields.</p>
<p>The responsibility of the <code>Dispatcher</code> is to loop over the available <code>BackEndHandler</code>s in order to
find one that is capable of servicing the request.</p>
<p>Aside from selecting a suitable <code>BackEndHandler</code>, the <code>Dispatcher</code> does not perform any additional
processing of the request. It is passed to the next stage still in the form of the
<code>requests::Request</code> structure, which contains the parsed header fields and the unparsed body.</p>
<p>The next stage of processing is a branch point. The service contains only a single <code>Dispatcher</code>, but
there are multiple <code>BackEndHandler</code>s. The <code>Dispatcher</code> is informed about the available handlers via
a registration mechanism that executes at service start-up.</p>
<h2><a class="header" href="#the-back-end-handler" id="the-back-end-handler">The Back-End Handler</a></h2>
<p>The <code>BackEndHandler</code> accepts the request in order to route it to its associated provider. The flow
differs here depending on whether the provider is an in-process Rust <code>Provider</code> object, or a
provider residing in an out-of-process co-server. If the provider is in a co-server, the
<code>BackEndHandler</code> will use the wire protocol to re-serialize the request and transmit it to the
co-server's transport endpoint, where it will then block in order to wait for a response. The onward
flow within the co-server is beyond the scope of this document, since co-servers can have arbitrary
implementations.</p>
<p>Assuming that the provider is an in-process Rust <code>Provider</code> object, the <code>BackEndHandler</code> will
fully-decode the request in order to turn it into a model object from the <code>operations</code> module. These
model objects have names beginning with the prefix <code>Op</code>, such as <code>OpKeyCreate</code> or <code>OpKeyList</code>. Once
the operation model has been constructed, it is executed on the <code>Provider</code>.</p>
<h3><a class="header" href="#the-converter" id="the-converter">The Converter</a></h3>
<p>The <code>Converter</code> in the interface crate is responsible to deserialize the body of the request to an
operation from the <code>operations</code> module or to serialize a result to a response body. There is one
<code>Converter</code> per format of operation contracts. <code>protobuf</code> converter is currently implemented in the
interface.</p>
<p>The <code>Converter</code> implements the <code>Convert</code> trait. Possible converters are listed
<a href="parsec_service/converters.html">here</a>.</p>
<h2><a class="header" href="#the-provider" id="the-provider">The Provider</a></h2>
<p>The <code>Provider</code> is where the request is fulfilled using whatever combined software and hardware stack
it has been coded for. The service can support any number of providers to interact with platform
facilities such as TPM, HSM or TA. The provider does whatever is necessary to implement the
operation. It then returns a result. Results are also communicated using model objects from the
<code>operations</code> module. These have names with the prefix <code>Result</code>, such as <code>ResultKeyCreate</code> or
<code>ResultKeyList</code>. This is where the data flow changes direction and begins its return journey to the
client application. For a more detailed description of the current providers, see the
<a href="parsec_service/providers.html"><strong>Providers</strong></a> page.</p>
<p>The <code>Provider</code> implements the <code>Provide</code> trait.</p>
<h3><a class="header" href="#the-key-info-manager" id="the-key-info-manager">The Key Info Manager</a></h3>
<p>Providers may make use of Key Info Managers to persistently and safely store key information
material, and thus another step for conversion from key name to provider-specific identifier is
needed.</p>
<p>The <code>KeyInfoManager</code> implements the <code>ManageKeyInfo</code> trait. Possible key info managers are listed
<a href="parsec_service/key_info_managers.html">here</a>.</p>
<h2><a class="header" href="#return-journey" id="return-journey">Return Journey</a></h2>
<p>The return journey is a mirror-image of what has been described above, except that there is no
dispatch phase (because the provider has already been chosen). The result is handled by the
<code>BackEndHandler</code>, which uses the correct encoding scheme (currently always protobuf) to serialize
the operation outputs into a new <code>requests::Response</code> struct. It also populates the response header
fields.</p>
<p>The <code>Response</code> is passed directly back from the <code>Dispatcher</code> to the <code>FrontEndHandler</code>, which uses
the rules of the wire protocol to transform the response header into a byte stream that can be
concatenated with the operation outputs that were already serialized in the above step. Again, it
makes use of serialization functions in the <code>interface</code> crate to serialize the header.</p>
<p>The response, at this stage, is now simply a sequence of bytes, which can be written back to the
transport endpoint by the <code>FrontEndHandler</code>, thus completing the cycle.</p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#source-code-structure-1" id="source-code-structure-1">Source Code Structure</a></h1>
<h2><a class="header" href="#introduction-5" id="introduction-5">Introduction</a></h2>
<p>This document presents the overall organisation of the source code repository, and provides pointers
to key definitions and implementations.</p>
<h2><a class="header" href="#status-1" id="status-1">Status</a></h2>
<p>This is preliminary documentation. It may be incomplete, and is subject to change without notice.</p>
<h2><a class="header" href="#audience-2" id="audience-2">Audience</a></h2>
<p>An understanding of the source code repository structure is essential for developers who are
contributing functionality to the service or any of its client libraries.</p>
<h2><a class="header" href="#overview-1" id="overview-1">Overview</a></h2>
<p>This project is a client-server system. It is composed of a service which exposes an API to clients
that reside in separate processes on the same host. An IPC mechanism is defined to allow these
external client processes to call the API in any programming language. This project maintains client
libraries for a number of popular programming languages. The service itself is written in the
<a href="https://www.rust-lang.org">Rust</a> programming language. The API provides access to platform security
facilities for key management and cryptography. Client applications call the API in order to access
these facilities without needing to know about the underlying platform hardware. The service
fulfills the operations by routing them to whatever platform facilities are available, such as a
Hardware Security Module (HSM), Trusted Platform Module (TPM) or Trusted Application (TA).</p>
<p>The API is closely aligned with the <a href="https://github.com/ARMmbed/mbed-crypto/blob/psa-crypto-api/docs/PSA_Cryptography_API_Specification.pdf">Platform Security Architecture (PSA) Crypto
API</a>.
PSA Crypto is specifically a C interface. This project takes the operations of that C interface and
wraps each of them in an IPC <a href="parsec_service/../parsec_client/wire_protocol.html">wire protocol</a>. There is
intentionally a very close correpondence between the two APIs, and the contracts of the operations
are identical in the majority of cases. However, the service also exposes a number of new operations
that are designed to help clients consume it more easily.</p>
<p>The source code is organised into three main components: the
<a href="https://github.com/parallaxsecond/parsec"><strong>service</strong></a>, the
<a href="https://github.com/parallaxsecond/parsec-client-go"><strong>client</strong></a> and the
<a href="https://github.com/parallaxsecond/parsec-interface-rs"><strong>interface</strong></a>. Each of these components is
distributed as a GitHub repository.</p>
<p>Other items are the <strong>docs</strong>, found in the service and which contains all of the documentation for
the project (some of which you are reading now), the
<a href="https://github.com/parallaxsecond/parsec-client-test"><strong>test</strong></a> repository, which contains
integration tests for the end-to-end system, and the
<a href="https://github.com/parallaxsecond/parsec-operations"><strong>operations</strong></a> repository which contains the
language-agnostic contracts for communicating with the service.</p>
<p>The remainder of the document will examine the contents of these repositories.</p>
<h2><a class="header" href="#the-service-repository" id="the-service-repository">The Service Repository</a></h2>
<p>The <code>service</code> repository contains the code for the service. The service is written in
<a href="https://www.rust-lang.org"><strong>Rust</strong></a>. Rust projects are organised into modular units known as
<a href="https://doc.rust-lang.org/beta/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong>crates</strong></a>,
each of which is formed of one or more
<a href="https://doc.rust-lang.org/beta/book/ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong>modules</strong></a>,
which are built using the <a href="https://doc.rust-lang.org/beta/book/ch01-03-hello-cargo.html"><strong>Cargo</strong></a>
build system. A Rust crate can be compiled into either a library or an executable. The service is
composed of a series of modules - represented by folders - defining the major components of the
system.</p>
<p>The <code>bin</code> directory defines the executable which links all the components together and runs the main
loop of the service.</p>
<p>The <code>front</code> module houses the code for the front-end functionality of the service. The front-end is
responsible for listening on the endpoint, such as a domain socket, and using the <a href="parsec_service/../parsec_client/wire_protocol.html">wire
protocol</a> to read and interpret API requests from clients. The
front-end is also responsible for serializing responses according to the same wire protocol, in
order to relay them back to the calling client.</p>
<p>The <code>back</code> module is responsible for routing client API requests to a back-end <strong>provider</strong>. A
provider is a module that knows how to fulfill a request using available platform facilities such as
HSM, TPM, TA or software. The service can be linked against one or more providers. The back-end
module could evolve to include a registration mechanism that allows the providers to announce their
presence in the overall system. There is also a dispatch mechanism that allows each incoming request
to be routed to the appropriate provider. The provider is instructed to perform the operation, and
the results are marshalled back to the front-end for onward serialization and return to the client.</p>
<p>The <code>authenticators</code> module contains the components that carry out the authentication of incoming
requests. Depending on the <code>auth_type</code> specified in the request header, the appropriate
authenticator is selected to parse and assess the <code>authentication</code> request field. The result is
either an error or the identifier of the application sending the request. Authenticators may use the
underlying security hardware to determine if the request has been correctly authenticated. For a
more detailed description of authentication and application identity, see the <a href="parsec_service/../parsec_client/api_overview.html"><strong>API
overview</strong></a>.</p>
<p>The <code>key_info_managers</code> module offers functionality for the providers for persisting mappings
between key names and provider-specific key information. The key info managers close the gap between
the API, which allows keys to be addressed by a UTF-8 name, and the providers which have specific
requirements for key handles (e.g. Mbed Crypto uses a 32 bit value for handles of persistent keys).
Using a key info manager is only required for persistent keys and the only current implementation
stores the mappings on disk.</p>
<p>Building the service will combine the frontend and backend components mentioned above into one
executable. It also links additional Rust crates that contain the providers, as well as crates to
support the IPC interface. On Linux systems, this binary runs as a daemon. While it is running,
client applications (on the same host) can locate the endpoint and make API calls.</p>
<h3><a class="header" href="#the-providers-sub-folder" id="the-providers-sub-folder">The Providers Sub-Folder</a></h3>
<p>The <code>provider</code> folder contains the provider modules, which connect the service back-end with the
hardware or software security facilities of supported target platforms.</p>
<p>Currently each provider sits in its own module implementing all the functionality needed to mediate
between the PSA interface and the platform it supports. This generally involves two types of
mediation:</p>
<ul>
<li>process convergence: the code implementing the operation calls is geared towards executing
identical cryptographic operations using different APIs; this can include functionality that is
not directly related to the desired operation (e.g. setting up sessions, managing key material
etc.).</li>
<li>data convergence: data passed into and returned from every operation should be
provider-independent; however, APIs can and tend to have differing ways of describing algorithms,
schemes, response codes and so on, and thus require conversion utilities; a similar, tangential
issue is that of encoding formats used or expected by underlying APIs.</li>
</ul>
<p><a href="parsec_service/providers.html">Providers</a> can be conditionally linked into the service as described in the <a href="parsec_service/build_run.html">Parsec
build</a> documentation.</p>
<p>Like the <code>client</code> folder, the <code>provider</code> folder is also a key extension point for partner
contributors. This project eagerly welcomes contributions of new providers in order to connect the
service with the security facilities of host platforms and extend the ecosystem.</p>
<p>It is not necessary for providers to be written in Rust. A provider must be written in Rust in order
to be statically linked into the core service and hence to reside within the same running process.
But the architecture also supports providers running as separate processes. These providers can be
written in any suitable programming language. This will be an option to consider if you wish to
contribute a new back-end provider, but you wish to use a programming language other than Rust.
Currently the service implementation does not offer this functionality.</p>
<h2><a class="header" href="#the-interface-repository" id="the-interface-repository">The Interface Repository</a></h2>
<p>The <code>interface</code> crate contains the Rust code that is needed to allow the service to conform to the
interface and wire protocol. It is also used by the Rust client library, but it is not used by other
client libraries (since those are written in other languages).</p>
<p>The crate contains three Rust modules: <code>requests</code>, <code>operations</code> and <code>operations_protobuf</code>.</p>
<p>The <code>requests</code> module defines model objects for request and response headers as described in the
wire protocol specification. It also contains the Rust code needed to serialize and de-serialize
these header structures (a process sometimes known as <em>marshalling</em>). This code is hand-written and
verified according to the written specification. It is not auto-generated, and it is unrelated to
the protobuf API contracts. The <code>requests</code> module functions according to the wire protocol
specification, regardless of whether protobuf is used in request body. This leaves the door open for
supporting schemes other than protobuf in the future.</p>
<p>The <code>operations</code> module defines model objects for each of the operations in the API. Again, these
definitions are independent of protobuf so that encoding schemes other than protobuf can be adopted
if needed. The Rust structs in the operations module capture the specific inputs and outputs for
each API operation.</p>
<p>The <code>operations_protobuf</code> module provides compatibility between the protobuf contracts and the
equivalent model objects in the <code>operations</code> module. Auto-generated code is generated from the
protobuf contracts at build-time, and is injected into this module, alongside hand-written
converters that translate to and from the <code>operations</code> structs. This extra level of translation may
seem cumbersome, but it is important in order to isolate the use of protobuf from the rest of the
system, so that a different encoding scheme could be adopted in the future without affecting
anything else. Most of the service uses the <code>operations</code> module to model API operations and their
results.</p>
<h2><a class="header" href="#the-operations-repository" id="the-operations-repository">The Operations Repository</a></h2>
<p>The <code>protobuf</code> folder in the <code>operations</code> repository contains the language-neutral input and output
contracts of all of the operations that are supported in the API. This includes all of the
operations derived from the PSA Crypto API Specification, as well as additional operations that are
specific to this service. All of these contracts are defined using <a href="https://developers.google.com/protocol-buffers/"><strong>protocol
buffers</strong></a>, also known as <strong>protobuf</strong>. Refer to
the <a href="parsec_service/../parsec_client/wire_protocol.html"><strong>wire protocol specification</strong></a> for more details on the use
of protobuf. The protobuf contracts are programming-language-agnostic, and can be used to develop
interoperable code within both the service and the client.</p>
<p>The API is a collection of <a href="parsec_service/../parsec_client/operations"><strong>operations</strong></a>. Each operation is denoted
by an integer <strong>opcode</strong>, an <strong>input contract</strong> and an <strong>output contract</strong>. Each input contract and
output contract is defined using a protobuf <strong>message</strong> structure. These messages collect together
the inputs and outputs of each operation. The messages can be used in combination with a <a href="https://github.com/protocolbuffers/protobuf"><strong>protobuf
compiler</strong></a> tool to generate language bindings for
these inputs and outputs. A client library uses these bindings alongside code derived from the
<a href="parsec_service/../parsec_client/wire_protocol.html"><strong>wire protocol specification</strong></a> in order to create a complete
language binding for the API.</p>
<h2><a class="header" href="#the-client-repositories" id="the-client-repositories">The Client Repositories</a></h2>
<p>Client libraries are expected to reside in independent repositories, most likely inheriting the
<strong>protobuf</strong> contracts from the <code>operations</code> repository. Each client library is subject to its own
sub-structure, build system and documentation system underneath that. The structures and build
systems will naturally vary from one language to another, and these are not governed by the project
overall.</p>
<p>The <code>client</code> folder is a key extension point for partner contributors. This project eagerly welcomes
contributions of new client libraries in different programming languages in order to enhance the
ecosystem and increase adoption. The <a href="parsec_service/../parsec_users.html"><code>Parsec for users</code></a> page contains a list
of currently available client libraries.</p>
<h2><a class="header" href="#repository-map" id="repository-map">Repository Map</a></h2>
<p>Please refer to the following diagram to understand the overall code structure and the dependency
arcs between the modules.</p>
<p><img src="parsec_service/diagrams/source_code_structure.png" alt="Repository Map" /></p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#providers" id="providers">Providers</a></h1>
<p>This document offers details on the currently supported providers.</p>
<p>For information regarding the function providers play in the Parsec service, read the <a href="parsec_service/interfaces_and_dataflow.html"><em>Interfaces
and Dataflow</em></a> doc. For details on how the service code is structured
around providers, read the <a href="parsec_service/source_code_structure.html"><em>Source Code Structure</em></a> doc.</p>
<h2><a class="header" href="#core-provider" id="core-provider">Core Provider</a></h2>
<p><strong>Provider UUID: 47049873-2a43-4845-9d72-831eab668784</strong></p>
<p>The core provider is a non-cryptographic provider, tasked with storing and distributing both static
and dynamic information about the service. It is the base for service discovery, helping clients
identify what functionality is available.</p>
<p>One instance of the core provider must always be running with a provider ID of 0.</p>
<h2><a class="header" href="#mbed-provider" id="mbed-provider">Mbed Provider</a></h2>
<p><strong>Provider UUID: 1c1139dc-ad7c-47dc-ad6b-db6fdb466552</strong></p>
<p>The Mbed provider is a software-based provider built on top of Mbed Crypto - the reference
implementation of the PSA cryptography specification. Mbed Crypto is loaded as a static library and
executes with the rest of the service in user-space.</p>
<p>The software version of the Mbed provider is meant as a proof-of-concept and should not be used in
real-world environments. Future improvements will expand the security guarantee of Mbed Crypto-based
providers.</p>
<h2><a class="header" href="#tpm-provider" id="tpm-provider">TPM Provider</a></h2>
<p><strong>Provider UUID: 1e4954a4-ff21-46d3-ab0c-661eeb667e1d</strong></p>
<p>The TPM provider offers an abstraction over hardware (or software) Trusted Platform Modules (TPM)
version 2. It uses the TPM2 Software Stack <a href="https://trustedcomputinggroup.org/resource/tcg-tss-2-0-enhanced-system-api-esapi-specification/">Enhanced System
API</a>
to communicate with the TPM and thus requires the TSS libraries to be on the machine.</p>
<p>Follow the <a href="https://github.com/tpm2-software/tpm2-tss/blob/master/INSTALL.md">installation guide</a> to
install the TSS libraries. To use the &quot;device&quot; TCTI, the user running Parsec will need to have
access rights on <code>/dev/tpm0</code> and <code>/dev/tpmrm0</code>. For that matter, installing the udev rules is needed
and the user running Parsec will need to be in the <code>tss</code> group.</p>
<p>The provider operates with keys based in the Owner Hierarchy. Thus, Parsec needs to be able to
authenticate with the TPM and to create a primary key and children keys derived from the primary.
Given current constraints, only one request at a time can be serviced by this provider - the rest
being blocked, waiting their turn.</p>
<h2><a class="header" href="#pkcs-11-provider" id="pkcs-11-provider">PKCS 11 Provider</a></h2>
<p><strong>Provider UUID: 30e39502-eba6-4d60-a4af-c518b7f5e38f</strong></p>
<p>The PKCS11 provider is a wrapper around the PKCS 11 standard interface, capable of working with
software or hardware modules that expose this API. Linking is done dynamically, and requires a
library that can drive the crypto engine.</p>
<p>Connecting to the PKCS11 module requires a slot number and, ideally, a PIN number that secures the
slot.</p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#converters" id="converters">Converters</a></h1>
<h2><a class="header" href="#protobuf-converter" id="protobuf-converter">Protobuf Converter</a></h2>
<p>The Protobuf converter uses the Protobuf format for the operation contracts to convert between
request and response bodies and native operation objects. The Protobuf converter is the one
currently used in the Parsec service.</p>
<p><em>Copyright 2020 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#authenticators" id="authenticators">Authenticators</a></h1>
<h2><a class="header" href="#direct-authenticator" id="direct-authenticator">Direct Authenticator</a></h2>
<p>The direct authenticator, <a href="https://github.com/parallaxsecond/parsec-interface-rs/issues/22">currently
named</a> &quot;simple authenticator&quot; in
the code, directly parse the authentication field as a UTF-8 string and uses that as application
identity. The direct authenticator is the one currently used by the Parsec service.</p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#listeners" id="listeners">Listeners</a></h1>
<h2><a class="header" href="#domain-socket-listener" id="domain-socket-listener">Domain Socket Listener</a></h2>
<p>This listener communicates with its client using a <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix domain
socket</a>.</p>
<p>The socket path is: <code>/tmp/parsec/parsec.sock</code>.</p>
<p><em>Copyright 2020 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#key-info-managers" id="key-info-managers">Key Info Managers</a></h1>
<p>The key info stored by the key info managers consist in a structure composed of:</p>
<ul>
<li>an <code>id</code>, which is the reference to a key in the specific provider</li>
<li><code>attributes</code>, which are the attributes of the key</li>
</ul>
<h1><a class="header" href="#on-disk-key-info-manager" id="on-disk-key-info-manager">On-Disk Key Info Manager</a></h1>
<p>The on-disk key info manager stores the mapping between key triple and key information directly on
disk, in a folder with a configurable path.</p>
<p>The application and key name length are limited by the operating system Parsec is running on.</p>
<p><em>Copyright 2020 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#adding-a-new-parsec-provider" id="adding-a-new-parsec-provider">Adding a new Parsec Provider</a></h1>
<p>Creating new providers means enabling Parsec to work on new platforms and is one of the main goals
of the project. As such, the interface that must be implemented by each provider was built with
modularity in mind, allowing developers to choose which operations they implement and when. This
interface is represented by a Rust <a href="https://doc.rust-lang.org/book/ch10-02-traits.html"><code>trait</code></a> -
more precisely, the
<a href="https://github.com/parallaxsecond/parsec/blob/master/src/providers/mod.rs"><code>Provide</code></a> trait.</p>
<p>The full list of operations that can be implemented can be found in the link above and will be
expanded as the project progresses towards supporting more use cases.</p>
<p>Apart from <code>list_opcodes</code> and <code>describe</code>, no method is mandatory and client libraries are expected
to use these two operations to bootstrap their usage of the service. Thus, once an operation is
correctly supported, its opcode can be added to those returned by <code>list_opcodes</code>. Any operation that
is not implemented will return a response code of <code>UnsupportedOperation</code> by default.</p>
<p>Each provider must offer a description of itself in the shape of a
<a href="https://github.com/parallaxsecond/parsec-interface-rs/blob/master/src/operations/list_providers.rs"><code>ProviderInfo</code></a>
value, by implementing the <code>describe</code> method. The UUID identifying the provider is
developer-generated and should not clash with existing providers. This process also requires the new
provider to be added to the
<a href="https://github.com/parallaxsecond/parsec-interface-rs/blob/master/src/requests/mod.rs"><code>ProviderID</code></a>
enum.</p>
<p>Lots of care must be taken when implementing operations that the inputs and outputs are in the
correct format, especially in the case of byte arrays. Detailed description of all input and output
can be found in the <a href="parsec_service/../parsec_client/operations/README.html">operations documentation</a>.</p>
<p>A helpful utility that the Parsec service offers to providers is the use of key info managers. These
allow the provider to persist mappings between key names and key information material and is
generally needed since providers are expected to support UTF-8 encoded strings as key names.</p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#how-to-build-and-run-parsec" id="how-to-build-and-run-parsec">How to build and run Parsec</a></h1>
<p>This project is coded in the Rust Programming Language. To build it, you first need to <a href="https://www.rust-lang.org/tools/install">install
Rust</a>.</p>
<p>Because the providers supported by Parsec are dependent on libraries and/or hardware features
present on the platform, the build is fragmented through Rust features so that the resulting binary
only contains the desired providers. Currently the service provides the following features:
<code>mbed-crypto-provider</code>, <code>pkcs11-provider</code>, and <code>tpm-provider</code>. Please check the
<a href="parsec_service/build_run.html#dependencies">dependencies</a> for what is needed to build each provider.</p>
<p>In order for the service to be spun up, a number of parameters are required in a TOML file. The
repository contains an <a href="https://github.com/parallaxsecond/parsec/blob/master/config.toml">example</a>
of such a configuration file which shows all the options and their default values. You can also take
example of the ones used for testing, for example <a href="https://github.com/parallaxsecond/parsec/blob/master/e2e_tests/provider_cfg/tpm/config.toml">the TPM provider
one</a>.</p>
<p>The <code>mbed-crypto-provider</code> feature is going to be used as an example in this guide. This can be
replaced by a subset of the features mentioned above, space or comma separated. If you would like to
test the TPM or PKCS check the <a href="parsec_service/test.html#testing-the-tpm-provider-using-the-software-tpm">related
guides</a>.</p>
<p>For the <code>DomainSocket</code> listener, the socket folder needs to be created:</p>
<pre><code>mkdir /tmp/parsec
</code></pre>
<p>On a real deployment (as explained in our <a href="parsec_service/install_parsec_linux.html">installation guide</a>) specific
owners and permissions need to be set up on this folder. Those security settings will be checked by
the clients for them to make sure they are communicating with a trusted Parsec service. For testing
only, it is fine to keep the folder as it is.</p>
<p>To build and run Parsec from source:</p>
<pre><code>RUST_LOG=info cargo run --features mbed-crypto-provider
</code></pre>
<p><code>parsec</code> will then construct the service based on the configuration file and wait for clients.
Setting <code>RUST_LOG=info</code> on the command line is not needed if the log level was modified via the
configuration file.</p>
<p>At the end of initialization, it should print <code>Parsec is ready</code> which means that it is ready to take
requests from clients.</p>
<p>If the configuration file is not in the directory from which Parsec is run, its path must be passed
via a command-line argument:</p>
<pre><code>cargo run --features mbed-crypto-provider -- --config e2e_tests/provider_cfg/mbed-crypto/config.toml
</code></pre>
<p>From another terminal, it is now possible to execute the <a href="parsec_service/test.html#end-to-end-tests">end-to-end
tests</a> on Parsec!</p>
<pre><code>cd e2e_tests
cargo test normal_tests
</code></pre>
<h2><a class="header" href="#killing-parsec" id="killing-parsec">Killing Parsec</a></h2>
<p>On Linux, sending <code>SIGTERM</code> will gracefully terminate Parsec, waiting all of its threads to finish.</p>
<pre><code>pkill parsec
</code></pre>
<h2><a class="header" href="#reloading-parsec" id="reloading-parsec">Reloading Parsec</a></h2>
<p>On Linux, sending <code>SIGHUP</code> will reload Parsec: it will wait for its threads to finish, drop all of
its components, read the configuration and instantiate all the components again. It is usefull to
change the Parsec configuration without having to kill the service.</p>
<pre><code>pkill -SIGHUP parsec
</code></pre>
<h2><a class="header" href="#dependencies" id="dependencies">Dependencies</a></h2>
<p>The Parsec Interface needs the <code>protoc</code> command to be available on the <code>PATH</code> in order to use the
Protobuf contracts. On Ubuntu-like distributions, it can be installed via the package manager under
the name <code>protobuf-compiler</code>:</p>
<pre><code>sudo apt install protobuf-compiler
</code></pre>
<p>To use <code>bindgen</code> and generate the Rust to C wrappers, <code>libclang</code> (version at least 3.9) is needed:</p>
<pre><code>sudo apt install llvm-dev libclang-dev clang
</code></pre>
<p>Each provider has external dependencies that are needed to compile.</p>
<h3><a class="header" href="#mbed-crypto" id="mbed-crypto">Mbed Crypto</a></h3>
<p>The Mbed Crypto provider is built on top of the reference implementation of the PSA Cryptography
API. You can find a list of dependencies
<a href="https://github.com/parallaxsecond/rust-psa-crypto/tree/master/psa-crypto-sys">here</a>.</p>
<h3><a class="header" href="#pkcs-11-crypto" id="pkcs-11-crypto">PKCS 11 Crypto</a></h3>
<p>The PKCS 11 provider will try to dynamically load the library indicated in the configuration file,
hence a library implementing the PKCS 11 API is needed.</p>
<h3><a class="header" href="#tpm-crypto" id="tpm-crypto">TPM Crypto</a></h3>
<p>The TPM provider will try to build the <code>tss-esapi</code> crate which needs built TSS 2.0 esys and tctildr
libraries. It will use <code>pkg-config</code> to find them using the names <code>tss2-esys</code> and <code>tss2-tctildr</code>.
Make sure you also follow the requirements of the <a href="https://docs.rs/tss-esapi">tss-esapi crate</a>.</p>
<h2><a class="header" href="#cross-compiling-for-arm64" id="cross-compiling-for-arm64">Cross-compiling for Arm64</a></h2>
<p>To cross-compile the service for the Linux on Arm64 target, you will need to install the appropriate
toolchain for this target. By default the Arm GNU toolchain is used to compile Mbed Crypto and link
everything together. The <code>aarch64-linux-gnu-*</code> tools will be needed. Change <code>build-conf.toml</code> and
<code>.cargo/config</code> files to change the cross-compiling toolchain used. Just execute the following
command to cross-compile for the Linux on Arm64 target:</p>
<pre><code>cargo build --target aarch64-unknown-linux-gnu
</code></pre>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#how-to-securely-install-parsec-on-linux" id="how-to-securely-install-parsec-on-linux">How to securely install Parsec on Linux</a></h1>
<p>Parsec can be built and installed as a Linux daemon using systemd. The daemon is a systemd user
daemon run by the <code>parsec</code> user. Some manual steps are needed to make sure that permissions are set
up correctly so that Parsec is installed respecting the operational mitigations of our <a href="parsec_service/../threat_model/threat_model.html">threat
model</a>. Similarly to the threat model, this guide proposes
different alternatives in case an Identity Provider is available or not. The role and description of
an Identity Provider in Parsec is described in the <a href="https://parallaxsecond.github.io/parsec-book/parsec_service/system_architecture.html">System
Architecture</a>
page. Currently, Parsec does not support integration with any Identity Provider. To securely install
Parsec, please follow the steps of deployment <strong>without an Identity Provider</strong>.</p>
<p>If your Linux system uses systemd to manage daemons, you can follow these steps. <code>$DESIRED_FEATURES</code>
can be a space or comma-separated subset of: <code>mbed-crypto-provider</code>, <code>pkcs11-provider</code>, and
<code>tpm-provider</code>. Choose the providers you want to install depending on what is available on the
platform.</p>
<p>Create the Parsec socket directory.</p>
<pre><code>mkdir /tmp/parsec
</code></pre>
<p>In a deployment <strong>without an Identity Provider</strong>, create the <code>parsec-clients</code> group and set the
correct permissions on the socket folder. Mutually trusted Parsec Clients will need to be in that
group.</p>
<pre><code>sudo groupadd parsec-clients
sudo chown :parsec-clients /tmp/parsec
sudo chmod 750 /tmp/parsec
</code></pre>
<p>For example, adding the imaginary <code>parsec-client-1</code> user to the <code>parsec-clients</code> group:</p>
<pre><code>sudo usermod -a -G parsec-clients parsec-client-1
</code></pre>
<p>Users just added to that group might need to log-out and log-in again to make sure the change apply.</p>
<p>In a deployment <strong>with an Identity Provider</strong>, set the correct permissions on the socket folder.</p>
<pre><code>sudo chmod 755 /tmp/parsec
</code></pre>
<p>Create and log in to a new user named <code>parsec</code>.</p>
<pre><code>sudo useradd -m parsec
sudo passwd parsec
su --login parsec
</code></pre>
<p>Depending on which features of Parsec the <code>parsec</code> user is going to use, it might need to be given
more privileges in order to access some resources on the system. Refer to the
<a href="parsec_service/providers.html">Providers</a> page for more information.</p>
<p>In its home directory, pull and install Parsec as a daemon. If a Rust toolchain is not available
widely on the system, it will need to be <a href="https://www.rust-lang.org/tools/install">installed</a> for
that specific user.</p>
<pre><code>git clone https://github.com/parallaxsecond/parsec.git
cargo install --features $DESIRED_FEATURES --path parsec
</code></pre>
<p>Copy and adapt the <a href="parsec_service/configuration.html">configuration</a> you want to use. For a secure deployment, make
sure to activate the <code>log_error_details</code> option and to use a <code>trace</code> log level.</p>
<pre><code>cp parsec/config.toml config.toml
</code></pre>
<p>Install the systemd unit files and activate the Parsec socket.</p>
<pre><code>mkdir -p ~/.config/systemd/user
cp -r parsec/systemd-daemon/parsec.service ~/.config/systemd/user
systemctl --user enable parsec
systemctl --user start parsec
</code></pre>
<p><code>parsec-clients</code> users (with no IP) or every one (with IP) can now use Parsec! You can test it
(having logged in a <code>parsec-clients</code> user) going inside the <code>parsec/e2e_tests</code> directory and:</p>
<pre><code>cargo test normal_tests
</code></pre>
<p><em>Note:</em> if you encounter a &quot;Permission Denied&quot; error while executing the end-to-end tests, make sure
that the group change has taken effect. You can check it by calling <code>groups</code> with no arguments. If
you do not see <code>parsec-clients</code>, please try logging the user out and in again to apply the change.</p>
<p>Check the Parsec logs with:</p>
<pre><code>journalclt --user -u parsec
</code></pre>
<p>Reload the service:</p>
<pre><code>systemctl --user kill -s HUP parsec
</code></pre>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#parsec-configuration" id="parsec-configuration">Parsec Configuration</a></h1>
<p>All Parsec configuration is done at startup with a configuration file. The <code>config.toml</code> file needs
to be in the same directory where the <code>parsec</code> command is executed. Please check in the source code
of Parsec for an <a href="https://github.com/parallaxsecond/parsec/blob/master/config.toml">example</a> of a
configuration file.</p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#how-to-test-parsec" id="how-to-test-parsec">How to test Parsec</a></h1>
<p>Parsec relies on a mix of unit, end-to-end, integration, stress and fuzz tests. Unit tests are
usually found in the same module as the code they verify. End-to-end and stress tests can be found
in the <code>e2e_tests</code> directory (along with the code framework required for running them), and come in
two flavours: single-provider and all-providers. Integration tests are found in the <code>tests</code>
directory and test the public module that the <code>parsec-service</code> crate exports.</p>
<p>Single-provider tests do a thorough verification of each individual provider, while all-providers
tests check that the common functionality is capable of supporting multiple providers at the same
time. Another subcategory of integration tests are persistance tests which check that key material
is persisted through service restarts.</p>
<p>The stress test simply constructs and sends random requests as fast as possible using a
multithreaded client. Valid requests are sent intermittently so as to check that the service is
still up and working correctly.</p>
<p>The <code>ci.sh</code> script executes all tests and is used on the CI.
<a href="https://github.com/rust-lang/rustfmt"><code>rustfmt</code></a> and
<a href="https://github.com/rust-lang/rust-clippy"><code>clippy</code></a> are needed for code formatting and static
checks.</p>
<h2><a class="header" href="#executing-tests-manually" id="executing-tests-manually">Executing tests manually</a></h2>
<h3><a class="header" href="#static-tests" id="static-tests">Static tests</a></h3>
<h4><a class="header" href="#checking-code-formatting" id="checking-code-formatting">Checking code formatting</a></h4>
<pre><code>cargo fmt --all -- --check
</code></pre>
<h4><a class="header" href="#checking-lints" id="checking-lints">Checking lints</a></h4>
<pre><code>cargo clippy --all-targets --all-features -- -D clippy::all -D clippy::cargo
</code></pre>
<h3><a class="header" href="#unit-tests" id="unit-tests">Unit tests</a></h3>
<h4><a class="header" href="#doc-tests" id="doc-tests">Doc tests</a></h4>
<pre><code>cargo test --doc --all-features
</code></pre>
<h4><a class="header" href="#unit-tests-1" id="unit-tests-1">Unit tests</a></h4>
<pre><code>cargo test --lib --all-features
</code></pre>
<h3><a class="header" href="#integration-tests" id="integration-tests">Integration tests</a></h3>
<p>Executing doc, unit and integration tests (it is currently not possible to isolate only the
integration tests):</p>
<pre><code>cargo test --all-features
</code></pre>
<h3><a class="header" href="#end-to-end-tests" id="end-to-end-tests">End-to-end tests</a></h3>
<p>They need to be executed from the <code>e2e_tests</code> folder.</p>
<h4><a class="header" href="#normal-tests" id="normal-tests">Normal tests</a></h4>
<pre><code>cargo test normal_tests
</code></pre>
<h4><a class="header" href="#persistence-integration-tests" id="persistence-integration-tests">Persistence integration tests</a></h4>
<p>Those check if the Key Info mapping persist after a shutdown (check the <code>ci.sh</code> script for details
of commands to execute).</p>
<h4><a class="header" href="#stress-tests" id="stress-tests">Stress tests</a></h4>
<pre><code>cargo test stress_test
</code></pre>
<h4><a class="header" href="#all-providers-end-to-end-tests" id="all-providers-end-to-end-tests">All providers end-to-end tests.</a></h4>
<p>This expects the Parsec service to include all providers.</p>
<pre><code>cargo test all_providers
</code></pre>
<h2><a class="header" href="#fuzz-testing" id="fuzz-testing">Fuzz testing</a></h2>
<p>Fuzz testing works, at the moment, on a service level, generating random requests and sending them
to be processed. Running the fuzz tests can be done through the <code>fuzz.sh</code> script in the root of the
repository. <code>./fuzz.sh run</code> builds a Docker image where the fuzz tests will run. It then sets up the
environment and initiates the test in the container. The fuzzing engine
(<a href="http://llvm.org/docs/LibFuzzer.html">libFuzzer</a>) works by generating random inputs for a fuzzing
target and then observing the code segments reached using said input. To stop the fuzzer, simply run
<code>./fuzz.sh stop</code>. To view the logs of a currently executing fuzzer, run <code>./fuzz.sh follow</code>. Any
crashes or slow tests, as well as tests that lead to a timeout, are stored in
<code>./fuzz/artifacts/fuzz_service/</code>.</p>
<h2><a class="header" href="#testing-the-tpm-provider-using-the-software-tpm" id="testing-the-tpm-provider-using-the-software-tpm">Testing the TPM provider using the Software TPM</a></h2>
<p>If you do not have a hardware TPM, or you do not want to use it for tests, you might want to use the
IBM Software TPM. You will need to follow these steps:</p>
<ul>
<li>install the TSS libraries (<a href="https://github.com/tpm2-software/tpm2-tss/blob/master/INSTALL.md">installation
guide</a>). Parsec has been tested
with version 2.3.3.</li>
<li>install the <a href="https://github.com/tpm2-software/tpm2-tools">TPM tools</a>. Parsec has been tested with
version 4.1.</li>
<li>install the <a href="https://sourceforge.net/projects/ibmswtpm2/">Software TPM</a>, run <code>make</code> in the <code>src</code>
directory. It will build the <code>tpm_server</code> executable.</li>
<li>install Parsec with the <code>tpm-provider</code> feature: <code>cargo build --features tpm-provider</code>.</li>
</ul>
<p>Once the required software is installed you can:</p>
<p>Launch the TPM server in the background (in the <code>src</code> folder where the TPM is installed):</p>
<pre><code>$ rm NVChip # this deletes the TPM cache
$ ./tpm_server &amp;
</code></pre>
<p>Use the TPM tools to startup the TPM server and set its owner hierarchy password (the tools need to
be on the <code>PATH</code>):</p>
<pre><code>$ tpm2_startup -c -T mssim
$ tpm2_changeauth -c owner tpm_pass -T mssim
</code></pre>
<p>Start Parsec with the TPM configuration:</p>
<pre><code>$ RUST_LOG=info ./target/debug/parsec -c e2e_tests/provider_cfg/tpm/config.toml
</code></pre>
<p>Which should print a <code>[INFO parsec] Parsec is ready.</code> You can now execute the end-to-end tests using
that provider!</p>
<h2><a class="header" href="#testing-the-pkcs11-provider-using-the-software-hsm" id="testing-the-pkcs11-provider-using-the-software-hsm">Testing the PKCS11 provider using the Software HSM</a></h2>
<p>If you do not have a hardware HSM, or you do not want to use it for tests, you might want to use the
Software HSM. You will need to follow these steps:</p>
<ul>
<li>install <a href="https://github.com/opendnssec/SoftHSMv2">SoftHSMv2</a>. We use version 2.5.0 for tests in
Parsec.</li>
<li>install Parsec with the <code>pkcs11-provider</code> feature: <code>cargo build --features pkcs11-provider</code>.</li>
</ul>
<p>Create a new token in a new slot. The slot number assigned will be random and is found with the
<code>find_slot_number</code> script.</p>
<pre><code>softhsm2-util --init-token --slot 0 --label &quot;Parsec Tests&quot; --pin 123456 --so-pin 123456
</code></pre>
<p>Find and append the slot number at the end of the configuration file:</p>
<pre><code>./e2e_tests/provider_cfg/pkcs11/find_slot_number.sh e2e_tests/provider_cfg/pkcs11/config.toml
</code></pre>
<p>Start Parsec with the PKCS11 configuration:</p>
<pre><code>$ RUST_LOG=info ./target/debug/parsec -c e2e_tests/provider_cfg/pkcs11/config.toml
</code></pre>
<p>Which should print a <code>[INFO parsec] Parsec is ready.</code> You can now execute the end-to-end tests using
that provider!</p>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#contribution-guidelines" id="contribution-guidelines">Contribution Guidelines</a></h1>
<p>Please follow the guidelines below to contribute to any Parsec repository.</p>
<ul>
<li>Contributions follow the GitHub Standard Fork and Pull Request workflow. <a href="https://gist.github.com/rjdmoore/ed014fba0ee2c7e75060ccd01b726cb8">This
guide</a> might help you if you
are not sure!</li>
<li>The changes are accepted under the <a href="https://developercertificate.org/">Developer Certificate of
Origin</a>, so you must add the <code>Author</code> and <code>Signed-off-by</code>
fields to your commit message. See [1]. By default, <code>git</code> should add the <code>Author</code> field
automatically so you just have to make sure that you commit your changes with <code>git commit --signoff</code> in order to add the <code>Sign-off-by</code> field.</li>
<li>The changes submitted need to pass the various Continuous Integration checks before being merged.</li>
<li>The files of this project use a copyright notice referring to &quot;Contributors to the Parsec
project&quot;. The contributors are specified in the
<a href="https://github.com/parallaxsecond/parsec/blob/master/CONTRIBUTORS.md"><code>CONTRIBUTORS.md</code></a> file in
the <code>parallaxsecond/parsec</code> repository. If you want to, please make a pull-request in that
repository to include your name or your organization.</li>
</ul>
<p>[1] Required commit message fields:</p>
<pre><code>Author: Full Name &lt;email address&gt;
Signed-off-by: Full Name &lt;email address&gt;
</code></pre>
<p><em>Copyright 2019 Contributors to the Parsec project.</em></p>
<h1><a class="header" href="#adding-operations-to-parsec" id="adding-operations-to-parsec">Adding operations to Parsec</a></h1>
<p>This mini how-to will cover how to add operations to the Parsec service and Rust client. The steps
for adding a new provider operation will differ between providers, this guide will cover Mbed
Crypto. The steps for adding operations to <a href="contributing/adding_new_operation_how_to.html#parsec">Parsec</a>, <a href="contributing/adding_new_operation_how_to.html#parsec-interface-rs">Rust
interface</a>, and <a href="contributing/adding_new_operation_how_to.html#parsec-client-rust">Rust client</a> should be the same for all
backend providers.</p>
<h2><a class="header" href="#operation-specification" id="operation-specification">Operation specification</a></h2>
<h3><a class="header" href="#parsec-book" id="parsec-book">parsec-book</a></h3>
<p>Create the specification page for the Parsec Book, under
<a href="https://parallaxsecond.github.io/parsec-book/parsec_client/operations/index.html">Operations</a> (can
also be found in the menu on the left of all pages). Include operation details such as parameters,
results, errors specific to the operation, a description, and a link to the
<a href="contributing/adding_new_operation_how_to.html#parsec-operations">protobuf</a> contract (which will be created further on). Also update all API
tables on the <a href="contributing/../service_api_coverage.html">Service API</a> and <a href="contributing/../clients_api_coverage.html">Client API</a>
pages to reflect the new addition (create any API tables if they are missing).</p>
<p>The opcode used should be the next available one. To find this, go to
<a href="https://github.com/parallaxsecond/parsec-interface-rs/blob/master/src/operations/mod.rs"><code>parsec-interface-rs/src/requests/mod.rs</code></a>
and find the largest in-use opcode.</p>
<h3><a class="header" href="#parsec-operations" id="parsec-operations">parsec-operations</a></h3>
<p>Create the <code>protobuf</code> contracts in
<a href="https://github.com/parallaxsecond/parsec-operations/tree/master/protobuf"><code>parsec-operations</code></a>.
These are the contracts that client libraries use to communicate with the Parsec service.</p>
<h2><a class="header" href="#rust-interface" id="rust-interface">Rust Interface</a></h2>
<h3><a class="header" href="#parsec-interface-rs" id="parsec-interface-rs">parsec-interface-rs</a></h3>
<p>Create the Rust interfaces for the operation. These interfaces go between
<a href="contributing/adding_new_operation_how_to.html#parsec-operations"><code>protobuf</code></a> and the <a href="contributing/adding_new_operation_how_to.html#parsec">Parsec service</a> on the service side, and the Rust
client library and protobuf on the client side. Take care when deciding on datatypes. Sensitive data
should be wrapped in either
<a href="https://docs.rs/zeroize/latest/zeroize/struct.Zeroizing.html"><code>Zeroizing</code></a> or
<a href="https://docs.rs/secrecy/latest/secrecy/struct.Secret.html"><code>Secret</code></a> (choose depending on the
sensitivity of the data. Favour
<a href="https://docs.rs/zeroize/latest/zeroize/struct.Zeroizing.html"><code>Zeroizing</code></a> unless there is a clear
requirement for <a href="https://docs.rs/secrecy/latest/secrecy/struct.Secret.html"><code>Secret</code></a>) to ensure
they are wiped from memory when dropped and should not have any output for debugging. The operation
definitions are stored in
<a href="https://github.com/parallaxsecond/parsec-interface-rs/tree/master/src/operations"><code>src/operations/</code></a>.</p>
<p>A <code>validate</code> method can be added to allow easy validation of the properties of the operations, to
check if there are any conflicting options, or combinations of options that are invalid. Tests must
be added for each operation with a validate method, to check it catches all erroneous combinations
of operation, and passes valid combinations.</p>
<p>A converter then needs to be added to
<a href="https://github.com/parallaxsecond/parsec-interface-rs/tree/master/src/operations_protobuf"><code>src/operations_protobuf</code></a>.
This will convert to and from the protobuf contract and the Rust interface. There should be four
methods per operation; two for going to and from the operation struct, and two for going to and from
the result struct. Again, tests need to be added to ensure all conversions happen correctly.</p>
<p>Add your protobuf contracts to the
<a href="https://github.com/parallaxsecond/parsec-interface-rs/blob/f924c0f45695ebd88e34537934c579be8909cced/src/operations_protobuf/generated_ops.rs#L18"><code>include_protobuf_as_module</code></a>
block in
<a href="https://github.com/parallaxsecond/parsec-interface-rs/blob/master/src/operations_protobuf/generated_ops.rs"><code>src/operations_protobuf/generated_ops.rs</code></a>.
If your Rust operation and/or result interfaces do not contain any sensitive information, add them
to the
<a href="https://github.com/parallaxsecond/parsec-interface-rs/blob/f924c0f45695ebd88e34537934c579be8909cced/src/operations_protobuf/generated_ops.rs#L129"><code>empty_clear_message!</code></a>
block. Otherwise, implement
<a href="https://github.com/parallaxsecond/parsec-interface-rs/blob/f924c0f45695ebd88e34537934c579be8909cced/src/operations_protobuf/generated_ops.rs#L116"><code>ClearProtoMessage</code></a>
for the interface/s that contain sensitive information and
<a href="https://github.com/parallaxsecond/parsec-interface-rs/blob/f924c0f45695ebd88e34537934c579be8909cced/src/operations_protobuf/generated_ops.rs#L146"><code>zeroize</code></a>
any of the sensitive fields.</p>
<p>In
<a href="https://github.com/parallaxsecond/parsec-interface-rs/blob/master/src/requests/mod.rs"><code>src/requests/mod.rs</code></a>,
add the opcode that was specified in the <a href="contributing/adding_new_operation_how_to.html#parsec-book"><code>parsec-book</code></a> for the operation. Finally,
add the relevant
<a href="https://github.com/parallaxsecond/parsec-interface-rs/blob/f924c0f45695ebd88e34537934c579be8909cced/src/operations/mod.rs#L32"><code>NativeOperation</code></a>
and
<a href="https://github.com/parallaxsecond/parsec-interface-rs/blob/f924c0f45695ebd88e34537934c579be8909cced/src/operations/mod.rs#L79"><code>NativeResult</code></a>
entries, along with the mappings to the opcode from the
<a href="https://github.com/parallaxsecond/parsec-interface-rs/blob/f924c0f45695ebd88e34537934c579be8909cced/src/operations/mod.rs#L59"><code>NativeOperation</code></a>
and
<a href="https://github.com/parallaxsecond/parsec-interface-rs/blob/f924c0f45695ebd88e34537934c579be8909cced/src/operations/mod.rs#L106"><code>NativeResult</code></a>
to the Opcode. Then, add <code>From</code> implementations to <code>NativeOperation</code> and <code>NativeResult</code>.</p>
<p>Finally, add the <code>mod</code> declaration in
<a href="https://github.com/parallaxsecond/parsec-interface-rs/blob/master/src/operations_protobuf/mod.rs"><code>src/operations_protobuf/mod.rs</code></a>,
along with the entries in <code>body_to_operation</code>, <code>operation_to_body</code>, <code>body_to_result</code> and
<code>result_to_body</code>.</p>
<h2><a class="header" href="#parsec-rust-client" id="parsec-rust-client">Parsec Rust client</a></h2>
<h3><a class="header" href="#parsec-client-rust" id="parsec-client-rust">parsec-client-rust</a></h3>
<p>Add the user facing methods to
<a href="https://github.com/parallaxsecond/parsec-client-rust/blob/master/src/core/basic_client.rs"><code>src/core/basic_client.rs</code></a>.
These are what users interacting with Parsec using Rust will use as the entrypoint. They are also
what <a href="https://github.com/parallaxsecond/parsec/blob/master/e2e_tests/src/lib.rs">Parsec’s e2e test
suit</a> uses to test
Parsec, which is why this step comes before extending Parsec. Add the relevant tests to
<a href="https://github.com/parallaxsecond/parsec-client-rust/blob/master/src/core/testing/core_tests.rs"><code>src/core/testing/core_tests.rs</code></a>.</p>
<h3><a class="header" href="#other-clients-eg-go" id="other-clients-eg-go">Other clients (e.g. Go)</a></h3>
<p>The procedure for adding operations to another client library should be similar. We encourage that
all clients should be updated to allow the new operation is as many languages as possible.</p>
<h2><a class="header" href="#parsec-1" id="parsec-1">Parsec</a></h2>
<h3><a class="header" href="#psa-crypto-sys" id="psa-crypto-sys">psa-crypto-sys</a></h3>
<p>Locate the parts of the <a href="https://armmbed.github.io/mbed-crypto/html/index.html">PSA API</a> in Mbed
Crypto that will need to be used during the operation you are adding. This includes all constants,
datatypes, macros and functions. Note: Mbed Crypto does not yet fully conform to the PSA API 1.0
specification, so there may be inconsistencies between the PSA documentation and the macros and
functions that Mbed Crypto exposes.</p>
<p>Starting in
<a href="https://github.com/parallaxsecond/rust-psa-crypto/tree/master/psa-crypto-sys"><code>psa-crypto-sys</code></a>,
constants are added to
<a href="https://github.com/parallaxsecond/rust-psa-crypto/blob/master/psa-crypto-sys/src/constants.rs"><code>constants.rs</code></a>.
Inline functions and macros require a shim. Add the inline function and macro definitions into
<a href="https://github.com/parallaxsecond/rust-psa-crypto/blob/master/psa-crypto-sys/src/c/shim.h"><code>shim.h</code></a>,
<a href="https://github.com/parallaxsecond/rust-psa-crypto/blob/master/psa-crypto-sys/src/c/shim.c"><code>shim.c</code></a>
and
<a href="https://github.com/parallaxsecond/rust-psa-crypto/blob/master/psa-crypto-sys/src/shim_methods.rs"><code>shim_methods.rs</code></a>.
When adding entries to
<a href="https://github.com/parallaxsecond/rust-psa-crypto/blob/master/psa-crypto-sys/src/shim_methods.rs"><code>shim_methods.rs</code></a>,
take note of where you place
<a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code"><code>unsafe</code></a>.
If the <a href="https://armmbed.github.io/mbed-crypto/html/index.html">PSA API</a> specification states that
under any circumstance, an unspecified result can be returned, then mark the entire <code>fn</code> definition
as <code>unsafe</code>. Otherwise, if the return values are always specified, wrap the call to the shim method
as <code>unsafe</code>. Regular functions are added to <a href="https://github.com/parallaxsecond/rust-psa-crypto/blob/master/psa-crypto-sys/src/lib.rs"><code>pub use psa_crypto_binding::{ … }</code></a>.</p>
<h3><a class="header" href="#psa-crypto" id="psa-crypto">psa-crypto</a></h3>
<p>Define a Rust native interface for the operation you are adding in
<a href="https://github.com/parallaxsecond/rust-psa-crypto/tree/master/psa-crypto/src/operations"><code>src/operations</code></a>,
along with any Rust native types you need in
<a href="https://github.com/parallaxsecond/rust-psa-crypto/tree/master/psa-crypto/src/types"><code>src/types</code></a>.
Generally, any helper macro functions are placed in the <code>impl</code> block of the Rust native type they
are for.</p>
<p>The interface will work between the Rust native datatypes given to it and the C bindings in
<a href="contributing/adding_new_operation_how_to.html#psa-crypto-sys"><code>psa-crypto-sys</code></a>. It is important to ensure that the Rust interface handles all
possible situations (e.g. closing a key-handle on an error) to ensure it is a safe Rust native
interface to the operation.</p>
<p>At this point, you will now have a safe Rust interface for the PSA operation you added.</p>
<h3><a class="header" href="#parsec-2" id="parsec-2">parsec</a></h3>
<p>Add the new operation to the correct
<a href="https://github.com/parallaxsecond/parsec/tree/master/src/providers">provider</a> (in this case, <a href="https://github.com/parallaxsecond/parsec/tree/master/src/providers/mbed_provider">Mbed
Crypto</a>) as a
<code>psa_xxx_internal</code> method. The operation method should take the user inputs, arrange them in a way
that <a href="contributing/adding_new_operation_how_to.html#psa-crypto"><code>psa-crypto</code></a> accepts, and provide any extra logic or storage if required (e.g.
an output buffer). The external implementation is to be added to the provider’s
<a href="https://github.com/parallaxsecond/parsec/blob/master/src/providers/mbed_provider/mod.rs"><code>mod.rs</code></a>
file, which outputs a trace entry and passes the call back to the internal implementation.</p>
<p>A default implementation is added to
<a href="https://github.com/parallaxsecond/parsec/blob/master/src/providers/mod.rs"><code>src/providers/mod.rs</code></a>
that is used when a provider does not support a particular operation. It outputs a trace entry and
returns an error, stating that the operation is not supported. The external implementation in the
provider’s <code>mod.rs</code> overrides this.</p>
<p>Add the <code>NativeOperation</code> mapping in
<a href="https://github.com/parallaxsecond/parsec/blob/master/src/back/backend_handler.rs"><code>src/back/backend_handler.rs</code></a>
<code>execute_request</code> function so Parsec can call the correct operation method when it receives a
request.</p>
<p>Finally, add <a href="https://github.com/parallaxsecond/parsec/tree/master/e2e_tests/tests/per_provider">end to end (e2e)
testing</a> for the
new operation. Operations are added to
<a href="https://github.com/parallaxsecond/parsec/blob/master/e2e_tests/src/lib.rs"><code>e2e_tests/src/lib.rs</code></a>
to save from code duplication in the tests. This also makes it quick and easy to write tests, and to
see exactly what operations a test is performing. Test should be very thorough, taking the operation
through valid and invalid inputs, checking that the proper output is returned. If possible, external
data and crates should be used during testing. E.g. if testing the cryptographic operation, generate
keys and an encrypted message externally and test that Parsec can correctly decrypt the message.
(Note: if crates are added solely for testing purposes, add them to <code>[dev-dependencies]</code> in
<a href="https://github.com/parallaxsecond/parsec/blob/master/e2e_tests/Cargo.toml"><code>Cargo.toml</code></a>)</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
